<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›®å½•æ ‘ç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            min-height: 800px;
        }

        .input-section {
            flex: 1;
            padding: 40px 30px 30px 30px;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
        }

        .output-section {
            flex: 1;
            padding: 40px 30px 30px 30px;
            background: #ffffff;
        }

        .section-title {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: #2c3e50;
            font-weight: 600;
        }

        .input-area {
            width: 100%;
            height: 700px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .input-area:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .output-area {
            width: 100%;
            height: 700px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            background: #f8f9fa;
            overflow-y: auto;
            white-space: pre;
            color: #2c3e50;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .format-options {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .format-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .format-option input[type="radio"] {
            margin-right: 5px;
        }

        .format-option input[type="checkbox"] {
            margin-right: 5px;
        }

        .example {
            background: #f5f7fa;
            border-left: 3px solid #b0bec5;
            padding: 10px 12px;
            margin: 24px 0 0 0;
            border-radius: 3px;
            font-size: 12px;
            color: #888;
        }

        .example-title {
            font-weight: 500;
            color: #90a4ae;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .example-content {
            font-family: 'Consolas', monospace;
            white-space: pre;
            font-size: 11px;
            color: #aaa;
            overflow-x: auto;
        }

        .btn-example {
            background: #e0e0e0;
            color: #666;
            font-size: 12px;
            padding: 6px 14px;
            border-radius: 4px;
            border: none;
            margin-left: auto;
            margin-top: 8px;
            display: block;
            transition: background 0.2s;
        }

        .btn-example:hover {
            background: #bdbdbd;
            color: #444;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .input-section {
                border-right: none;
                border-bottom: 2px solid #e9ecef;
            }

            .header h1 {
                font-size: 2rem;
            }

            .controls {
                justify-content: center;
            }

            .input-area, .output-area {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒ³ ç›®å½•æ ‘ç”Ÿæˆå™¨</h1>
            <p>è½»æ¾å°†æ–‡ä»¶åˆ—è¡¨è½¬æ¢ä¸ºç¾è§‚çš„æ ‘çŠ¶ç›®å½•ç»“æ„</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <h2 class="section-title">ğŸ“ è¾“å…¥æ–‡ä»¶åˆ—è¡¨</h2>

                <textarea
                    class="input-area"
                    id="inputText"
                    placeholder="è¯·è¾“å…¥æ–‡ä»¶/æ–‡ä»¶å¤¹åˆ—è¡¨ï¼Œæ”¯æŒç¼©è¿›è¡¨ç¤ºå±‚çº§å…³ç³»...&#10;æç¤ºï¼šæŒ‰ Tab é”®å¯ä»¥å¿«é€Ÿç¼©è¿›"
                    oninput="generateTree()"
                    onkeydown="handleTabKey(event)"
                ></textarea>

                <div class="format-options">
                    <div style="display: flex; flex-wrap: wrap; gap: 20px;">
                        <div style="flex: 1; min-width: 200px;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #2c3e50;">æ ‘å½¢æ ·å¼ï¼š</div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <div class="format-option">
                                    <input type="radio" id="format1" name="format" value="format1" checked onchange="generateTree()">
                                    <label for="format1">ç»å…¸æ ‘å½¢ (â”œâ”€â”€ â””â”€â”€)</label>
                                </div>
                                <div class="format-option">
                                    <input type="radio" id="format2" name="format" value="format2" onchange="generateTree()">
                                    <label for="format2">ç®€æ´æ ‘å½¢ (|-- `--)</label>
                                </div>
                                <div class="format-option">
                                    <input type="radio" id="format3" name="format" value="format3" onchange="generateTree()">
                                    <label for="format3">ASCII æ ‘å½¢ (+- \-)</label>
                                </div>
                            </div>
                        </div>
                        <div style="flex: 1; min-width: 150px;">
                            <div style="font-weight: 600; margin-bottom: 10px; color: #2c3e50;">æ˜¾ç¤ºé€‰é¡¹ï¼š</div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <div class="format-option">
                                    <input type="checkbox" id="showEmoji" onchange="generateTree()">
                                    <label for="showEmoji">æ˜¾ç¤ºå›¾æ ‡ ğŸ“ğŸ“„</label>
                                </div>
                                <div class="format-option">
                                    <input type="checkbox" id="showComments" checked onchange="generateTree()">
                                    <label for="showComments">æ˜¾ç¤ºæ³¨é‡Š ğŸ’¬</label>
                                </div>
                                <div class="format-option">
                                    <input type="checkbox" id="addVirtualRoot" checked onchange="generateTree()">
                                    <label for="addVirtualRoot">æ·»åŠ è™šæ‹Ÿæ ¹ç›®å½• ğŸŒ³</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="generateTree()">
                        ğŸ”„ ç”Ÿæˆç›®å½•æ ‘
                    </button>
                    <button class="btn btn-secondary" onclick="clearInput()">
                        ğŸ—‘ï¸ æ¸…ç©ºè¾“å…¥
                    </button>
                </div>

                <div class="example">
                    <div class="example-title">è¾“å…¥æ ¼å¼ç¤ºä¾‹</div>
                    <div class="example-content">src/  #æºä»£ç ç›®å½•
    components/  #ç»„ä»¶æ–‡ä»¶å¤¹
        Header.vue  #å¤´éƒ¨ç»„ä»¶
        Footer.vue  #åº•éƒ¨ç»„ä»¶
    utils/  #å·¥å…·å‡½æ•°ç›®å½•
        helper.js  #è¾…åŠ©å‡½æ•°
    main.js  #å…¥å£æ–‡ä»¶
public/  #é™æ€èµ„æºç›®å½•
    index.html  #ä¸»é¡µé¢
package.json  #é¡¹ç›®é…ç½®æ–‡ä»¶</div>
                    <button class="btn-example" onclick="loadExample()">ğŸ“ åŠ è½½ç¤ºä¾‹</button>
                </div>
            </div>

            <div class="output-section">
                <h2 class="section-title">ğŸŒ² ç”Ÿæˆçš„ç›®å½•æ ‘</h2>
                <div class="output-area" id="outputArea">è¯·åœ¨å·¦ä¾§è¾“å…¥æ–‡ä»¶åˆ—è¡¨...</div>

                <div class="controls">
                    <button class="btn btn-success" onclick="copyToClipboard()">
                        ğŸ“‹ å¤åˆ¶ç»“æœ
                    </button>
                    <button class="btn btn-secondary" onclick="downloadResult()">
                        ğŸ’¾ ä¸‹è½½æ–‡ä»¶
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å¤„ç†Tabé”®ç¼©è¿›åŠŸèƒ½
        function handleTabKey(event) {
            if (event.key === 'Tab') {
                event.preventDefault(); // é˜»æ­¢é»˜è®¤çš„Tabè¡Œä¸º

                const textarea = event.target;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const value = textarea.value;

                if (event.shiftKey) {
                    // Shift+Tab: å‡å°‘ç¼©è¿›
                    const lineStart = value.lastIndexOf('\n', start - 1) + 1;
                    const lineEnd = value.indexOf('\n', start);
                    const actualLineEnd = lineEnd === -1 ? value.length : lineEnd;
                    const currentLine = value.substring(lineStart, actualLineEnd);

                    // å¦‚æœè¡Œé¦–æœ‰4ä¸ªæˆ–æ›´å¤šç©ºæ ¼ï¼Œåˆ™åˆ é™¤4ä¸ªç©ºæ ¼
                    if (currentLine.startsWith('    ')) {
                        const newValue = value.substring(0, lineStart) +
                                       currentLine.substring(4) +
                                       value.substring(actualLineEnd);
                        textarea.value = newValue;

                        // è°ƒæ•´å…‰æ ‡ä½ç½®
                        const newCursorPos = Math.max(lineStart, start - 4);
                        textarea.setSelectionRange(newCursorPos, newCursorPos);
                    }
                } else {
                    // Tab: å¢åŠ ç¼©è¿›ï¼ˆæ’å…¥4ä¸ªç©ºæ ¼ï¼‰
                    const newValue = value.substring(0, start) + '    ' + value.substring(end);
                    textarea.value = newValue;

                    // è®¾ç½®å…‰æ ‡ä½ç½®
                    textarea.setSelectionRange(start + 4, start + 4);
                }

                // è§¦å‘è¾“å…¥äº‹ä»¶ä»¥æ›´æ–°æ ‘å½¢ç»“æ„
                generateTree();
            }
        }

        // æ ‘å½¢ç»“æ„çš„å­—ç¬¦é›†åˆ
        const treeFormats = {
            format1: {
                branch: 'â”œâ”€â”€ ',
                lastBranch: 'â””â”€â”€ ',
                vertical: 'â”‚   ',
                space: '    '
            },
            format2: {
                branch: '|-- ',
                lastBranch: '`-- ',
                vertical: '|   ',
                space: '    '
            },
            format3: {
                branch: '+-- ',
                lastBranch: '\\-- ',
                vertical: '|   ',
                space: '    '
            }
        };

        function parseInput(text) {
            if (!text.trim()) return [];

            const lines = text.split('\n').filter(line => line.trim());
            const result = [];

            lines.forEach((line, lineIndex) => {
                try {
                    // è®¡ç®—ç¼©è¿›çº§åˆ«
                    const indentMatch = line.match(/^(\s*)/);
                    const indent = indentMatch ? indentMatch[1].length : 0;
                    const level = Math.floor(indent / 4); // å‡è®¾æ¯çº§ç¼©è¿›4ä¸ªç©ºæ ¼

                    // æå–æ–‡ä»¶åå’Œæ³¨é‡Š
                    const contentPart = line.trim();
                    let name = contentPart;
                    let comment = '';

                    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†ç¦»æ–‡ä»¶åå’Œæ³¨é‡Š
                    const commentMatch = contentPart.match(/^(.+?)\s*#\s*(.+)$/);
                    if (commentMatch) {
                        name = commentMatch[1].trim();
                        comment = commentMatch[2].trim();
                    }

                    if (name) {
                        result.push({
                            name: name,
                            level: level,
                            isDirectory: name.endsWith('/'),
                            comment: comment
                        });
                    }
                } catch (error) {
                    console.error(`è§£æç¬¬ ${lineIndex + 1} è¡Œæ—¶å‡ºé”™:`, line, error);
                    // ç»§ç»­å¤„ç†å…¶ä»–è¡Œï¼Œä¸ä¸­æ–­æ•´ä¸ªè§£æè¿‡ç¨‹
                }
            });

            return result;
        }

        function addVirtualRootIfNeeded(items, addVirtualRoot) {
            if (!addVirtualRoot || items.length === 0) {
                return items;
            }

            // ç»Ÿè®¡æ ¹çº§åˆ«ï¼ˆlevel 0ï¼‰çš„é¡¹ç›®æ•°é‡
            const rootLevelItems = items.filter(item => item.level === 0);

            // å¦‚æœæ ¹çº§åˆ«é¡¹ç›®è¶…è¿‡1ä¸ªï¼Œæ·»åŠ è™šæ‹Ÿæ ¹ç›®å½•
            if (rootLevelItems.length > 1) {
                // ä¸ºæ‰€æœ‰ç°æœ‰é¡¹ç›®çš„å±‚çº§+1
                const adjustedItems = items.map(item => ({
                    ...item,
                    level: item.level + 1
                }));

                // æ·»åŠ è™šæ‹Ÿæ ¹ç›®å½•
                const virtualRoot = {
                    name: 'root/',
                    level: 0,
                    isDirectory: true,
                    comment: 'é¡¹ç›®æ ¹ç›®å½•'
                };

                return [virtualRoot, ...adjustedItems];
            }

            return items;
        }

        function generateTreeStructure(items, format, showEmoji = true, showComments = true, addVirtualRoot = true) {
            if (items.length === 0) return '';

            // å¤„ç†è™šæ‹Ÿæ ¹ç›®å½•
            const processedItems = addVirtualRootIfNeeded(items, addVirtualRoot);
            const chars = treeFormats[format];
            let result = '';

            // è®¡ç®—æ¯å±‚æœ€å¤§å®½åº¦ç”¨äºæ³¨é‡Šå¯¹é½
            let maxWidthByLevel = {};
            if (showComments) {
                processedItems.forEach(item => {
                    const { name, level, isDirectory } = item;
                    const icon = showEmoji ? (isDirectory ? 'ğŸ“ ' : 'ğŸ“„ ') : '';
                    const displayName = isDirectory ? name.slice(0, -1) : name;
                    let prefixLength = 0;
                    for (let i = 0; i < level; i++) {
                        prefixLength += 4;
                    }
                    const itemWidth = prefixLength + icon.length + displayName.length;
                    if (!maxWidthByLevel[level] || itemWidth > maxWidthByLevel[level]) {
                        maxWidthByLevel[level] = itemWidth;
                    }
                });
            }

            // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ç´¢å¼•
            const parentIndexes = [];
            for (let i = 0; i < processedItems.length; i++) {
                let parentIdx = -1;
                for (let j = i - 1; j >= 0; j--) {
                    if (processedItems[j].level === processedItems[i].level - 1) {
                        parentIdx = j;
                        break;
                    }
                }
                parentIndexes[i] = parentIdx;
            }

            // è®¡ç®—æ¯ä¸ªçˆ¶èŠ‚ç‚¹ä¸‹çš„æ‰€æœ‰å­èŠ‚ç‚¹ç´¢å¼•
            const childrenMap = {};
            for (let i = 0; i < processedItems.length; i++) {
                const parentIdx = parentIndexes[i];
                if (!childrenMap[parentIdx]) childrenMap[parentIdx] = [];
                childrenMap[parentIdx].push(i);
            }

            // ä¸»å¾ªç¯
            function renderTree() {
                let parentsHasNextSibling = [];
                for (let index = 0; index < processedItems.length; index++) {
                    const item = processedItems[index];
                    const { name, level, isDirectory, comment } = item;
                    // åˆ¤æ–­è‡ªå·±æ˜¯å¦ä¸ºåŒçˆ¶çº§ä¸‹çš„æœ€åä¸€ä¸ª
                    const parentIdx = parentIndexes[index];
                    const siblings = childrenMap[parentIdx];
                    const isLastInParent = siblings[siblings.length - 1] === index;

                    // å¤åˆ¶çˆ¶çº§çŠ¶æ€ï¼Œé¿å…æ±¡æŸ“
                    let currentParentsHasNextSibling = parentsHasNextSibling.slice(0, level);
                    if (level > 0) {
                        currentParentsHasNextSibling[level - 1] = !isLastInParent;
                    }

                    // ç”Ÿæˆå‰ç¼€
                    let prefix = '';
                    for (let i = 0; i < level - 1; i++) {
                        prefix += currentParentsHasNextSibling[i] ? chars.vertical : chars.space;
                    }
                    if (level > 0) {
                        prefix += isLastInParent ? chars.lastBranch : chars.branch;
                    }

                    // å›¾æ ‡å’Œåç§°
                    const icon = showEmoji ? (isDirectory ? 'ğŸ“ ' : 'ğŸ“„ ') : '';
                    const displayName = isDirectory ? name.slice(0, -1) : name;
                    let lineContent = prefix + icon + displayName;

                    // æ³¨é‡Š
                    if (showComments && comment) {
                        const currentWidth = lineContent.length;
                        let targetWidth = currentWidth;
                        Object.keys(maxWidthByLevel).forEach(l => {
                            if (maxWidthByLevel[l] > targetWidth) {
                                targetWidth = maxWidthByLevel[l];
                            }
                        });
                        const spacesNeeded = Math.max(2, targetWidth - currentWidth + 2);
                        lineContent += ' '.repeat(spacesNeeded) + '# ' + comment;
                    }
                    result += lineContent + '\n';

                    // æ›´æ–°å…¨å±€parentsHasNextSibling
                    parentsHasNextSibling = currentParentsHasNextSibling;
                }
            }

            renderTree();
            return result;
        }

        function generateTree() {
            const inputText = document.getElementById('inputText').value;
            const selectedFormat = document.querySelector('input[name="format"]:checked').value;
            const showEmoji = document.getElementById('showEmoji').checked;
            const showComments = document.getElementById('showComments').checked;
            const addVirtualRoot = document.getElementById('addVirtualRoot').checked;
            const outputArea = document.getElementById('outputArea');

            try {
                if (!inputText.trim()) {
                    outputArea.textContent = 'è¯·åœ¨å·¦ä¾§è¾“å…¥æ–‡ä»¶åˆ—è¡¨...';
                    return;
                }

                const items = parseInput(inputText);

                if (items.length === 0) {
                    outputArea.textContent = 'è§£æå¤±è´¥ï¼šæœªèƒ½è¯†åˆ«åˆ°æœ‰æ•ˆçš„æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹';
                    return;
                }

                const treeStructure = generateTreeStructure(items, selectedFormat, showEmoji, showComments, addVirtualRoot);

                if (!treeStructure || treeStructure.trim() === '') {
                    outputArea.textContent = 'ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥æ ¼å¼';
                    return;
                }

                outputArea.textContent = treeStructure;
            } catch (error) {
                outputArea.textContent = 'ç”Ÿæˆé”™è¯¯: ' + error.message;
                console.error('ç”Ÿæˆç›®å½•æ ‘æ—¶å‘ç”Ÿé”™è¯¯:', error);
            }
        }

        function clearInput() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputArea').textContent = 'è¯·åœ¨å·¦ä¾§è¾“å…¥æ–‡ä»¶åˆ—è¡¨...';
        }

        function loadExample() {
            const exampleText = `frontend/           # å‰ç«¯é¡¹ç›®
    src/            # æºä»£ç ç›®å½•
        components/ # ç»„ä»¶æ–‡ä»¶å¤¹
            Header.vue # å¤´éƒ¨ç»„ä»¶
            Footer.vue # åº•éƒ¨ç»„ä»¶
        utils/      # å·¥å…·å‡½æ•°ç›®å½•
            helper.js # è¾…åŠ©å‡½æ•°
        main.js     # å…¥å£æ–‡ä»¶
    package.json    # é¡¹ç›®é…ç½®æ–‡ä»¶
backend/            # åç«¯é¡¹ç›®
    src/            # æºä»£ç ç›®å½•
        controllers/ # æ§åˆ¶å™¨
            user.js # ç”¨æˆ·æ§åˆ¶å™¨
        models/     # æ•°æ®æ¨¡å‹
            User.js # ç”¨æˆ·æ¨¡å‹
        app.js      # åº”ç”¨å…¥å£
    package.json    # é¡¹ç›®é…ç½®æ–‡ä»¶
docs/               # æ–‡æ¡£ç›®å½•
    README.md       # é¡¹ç›®è¯´æ˜
    API.md          # APIæ–‡æ¡£
docker-compose.yml  # Dockeré…ç½®æ–‡ä»¶
.gitignore          # Gitå¿½ç•¥æ–‡ä»¶`;

            document.getElementById('inputText').value = exampleText;
            generateTree();
        }

        async function copyToClipboard() {
            const outputText = document.getElementById('outputArea').textContent;

            if (!outputText || outputText === 'è¯·åœ¨å·¦ä¾§è¾“å…¥æ–‡ä»¶åˆ—è¡¨...') {
                alert('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹ï¼');
                return;
            }

            try {
                await navigator.clipboard.writeText(outputText);

                // ä¸´æ—¶æ”¹å˜æŒ‰é’®æ–‡æœ¬ä»¥æ˜¾ç¤ºæˆåŠŸçŠ¶æ€
                const btn = document.querySelector('.btn-success');
                const originalText = btn.innerHTML;
                btn.innerHTML = 'âœ… å·²å¤åˆ¶!';
                btn.style.background = '#28a745';

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '';
                }, 2000);

            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿçš„é€‰æ‹©å’Œå¤åˆ¶æ–¹æ³•
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = outputText;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);

                    const btn = document.querySelector('.btn-success');
                    const originalText = btn.innerHTML;
                    btn.innerHTML = 'âœ… å·²å¤åˆ¶!';
                    btn.style.background = '#28a745';

                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.style.background = '';
                    }, 2000);
                } catch (fallbackErr) {
                    console.error('é™çº§å¤åˆ¶ä¹Ÿå¤±è´¥:', fallbackErr);
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¹¶å¤åˆ¶æ–‡æœ¬');
                }
            }
        }

        function downloadResult() {
            const outputText = document.getElementById('outputArea').textContent;

            if (!outputText || outputText === 'è¯·åœ¨å·¦ä¾§è¾“å…¥æ–‡ä»¶åˆ—è¡¨...') {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„å†…å®¹ï¼');
                return;
            }

            try {
                // åˆ›å»ºå¸¦BOMçš„UTF-8æ–‡æœ¬ä»¥ç¡®ä¿ä¸­æ–‡æ­£ç¡®æ˜¾ç¤º
                const BOM = '\uFEFF';
                const textWithBOM = BOM + outputText;
                const blob = new Blob([textWithBOM], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'directory-tree.txt';
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // ä¸´æ—¶æ”¹å˜æŒ‰é’®çŠ¶æ€
                const btns = document.querySelectorAll('.btn-secondary');
                const btn = btns[btns.length - 1]; // è·å–ä¸‹è½½æŒ‰é’®
                const originalText = btn.innerHTML;
                btn.innerHTML = 'âœ… ä¸‹è½½å®Œæˆ!';
                btn.style.background = '#28a745';

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '';
                }, 2000);

            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                alert('ä¸‹è½½å¤±è´¥: ' + error.message);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨åŠ è½½ç¤ºä¾‹
        window.addEventListener('load', function() {
            // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ä»¥ç¡®ä¿é¡µé¢å®Œå…¨æ¸²æŸ“
            setTimeout(() => {
                loadExample();
            }, 500);
        });
    </script>
</body>
</html>