<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éšå½¢æ°´å°æ£€æµ‹å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .upload-section {
            background: white;
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 30px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .image-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .image-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .image-container h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        canvas, img {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .controls h3 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            margin: 15px 0;
            flex-wrap: wrap;
            gap: 10px;
        }

        .control-group label {
            min-width: 120px;
            font-weight: bold;
            color: #555;
        }

        input[type="range"] {
            flex: 1;
            min-width: 200px;
            margin: 0 10px;
        }

        .value-display {
            background: #f0f0f0;
            padding: 5px 10px;
            border-radius: 15px;
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        .analysis-results {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .result-item {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 10px 10px 0;
        }

        .result-item.warning {
            border-left-color: #ffc107;
            background: #fff9c4;
        }

        .result-item.danger {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .histogram {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” éšå½¢æ°´å°æ£€æµ‹å™¨</h1>

        <div class="upload-section" id="uploadSection">
            <h3>ä¸Šä¼ å›¾ç‰‡è¿›è¡Œæ°´å°æ£€æµ‹ä¸æå–</h3>
            <p>æ”¯æŒ JPG, PNG, GIF ç­‰æ ¼å¼ | å¯æ£€æµ‹LSBã€Alphaé€šé“ã€é¢‘åŸŸæ°´å°</p>
            <input type="file" id="imageInput" class="file-input" accept="image/*">
            <button class="upload-btn" onclick="document.getElementById('imageInput').click()">
                ğŸ“ é€‰æ‹©å›¾ç‰‡
            </button>
            <p>æˆ–è€…æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤åŒºåŸŸ</p>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨åˆ†æå›¾ç‰‡ä¸­...</p>
        </div>

        <div class="controls" id="controls" style="display: none;">
            <h3>æ£€æµ‹å‚æ•°è°ƒæ•´</h3>
            <div class="control-group">
                <label>äº®åº¦å¢å¼º:</label>
                <input type="range" id="brightnessSlider" min="0" max="200" value="100">
                <span class="value-display" id="brightnessValue">100%</span>
            </div>
            <div class="control-group">
                <label>å¯¹æ¯”åº¦å¢å¼º:</label>
                <input type="range" id="contrastSlider" min="0" max="300" value="100">
                <span class="value-display" id="contrastValue">100%</span>
            </div>
            <div class="control-group">
                <label>ä¼½é©¬çŸ«æ­£:</label>
                <input type="range" id="gammaSlider" min="10" max="300" value="100">
                <span class="value-display" id="gammaValue">1.0</span>
            </div>
            <div class="control-group">
                <label>é”åŒ–ç¨‹åº¦:</label>
                <input type="range" id="sharpenSlider" min="0" max="100" value="0">
                <span class="value-display" id="sharpenValue">0</span>
            </div>
        </div>

        <div class="image-display" id="imageDisplay"></div>
        <div class="analysis-results" id="analysisResults" style="display: none;"></div>
    </div>

    <script>
        let originalImageData = null;
        let canvas = null;
        let ctx = null;

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function() {
            const imageInput = document.getElementById('imageInput');
            const uploadSection = document.getElementById('uploadSection');

            // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
            imageInput.addEventListener('change', handleFileSelect);

            // æ‹–æ‹½äº‹ä»¶
            uploadSection.addEventListener('dragover', handleDragOver);
            uploadSection.addEventListener('drop', handleDrop);
            uploadSection.addEventListener('dragenter', () => uploadSection.classList.add('dragover'));
            uploadSection.addEventListener('dragleave', () => uploadSection.classList.remove('dragover'));

            // æ»‘å—äº‹ä»¶ç›‘å¬å™¨
            setupSliderListeners();
        });

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('uploadSection').classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            // éªŒè¯æ–‡ä»¶ç±»å‹
            if (!file.type.startsWith('image/')) {
                alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }

            // é‡ç½®ç•Œé¢çŠ¶æ€
            document.getElementById('imageDisplay').innerHTML = '';
            document.getElementById('analysisResults').style.display = 'none';
            document.getElementById('controls').style.display = 'none';

            showLoading(true);

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    initializeCanvas(img);
                    performWatermarkDetection();
                    showLoading(false);
                    document.getElementById('controls').style.display = 'block';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function initializeCanvas(img) {
            const imageDisplay = document.getElementById('imageDisplay');
            imageDisplay.innerHTML = '';

            // åˆ›å»ºåŸå§‹å›¾ç‰‡æ˜¾ç¤º
            const originalContainer = document.createElement('div');
            originalContainer.className = 'image-container';
            originalContainer.innerHTML = `
                <h3>åŸå§‹å›¾ç‰‡</h3>
                <img src="${img.src}" alt="åŸå§‹å›¾ç‰‡">
            `;
            imageDisplay.appendChild(originalContainer);

            // åˆ›å»ºåˆ†æç”»å¸ƒ
            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');

            // è®¾ç½®ç”»å¸ƒå°ºå¯¸ï¼ˆé™åˆ¶æœ€å¤§å°ºå¯¸ä»¥æé«˜æ€§èƒ½ï¼‰
            const maxSize = 800;
            let { width, height } = img;

            if (width > maxSize || height > maxSize) {
                const ratio = Math.min(maxSize / width, maxSize / height);
                width *= ratio;
                height *= ratio;
            }

            canvas.width = width;
            canvas.height = height;

            // ç»˜åˆ¶åŸå§‹å›¾ç‰‡
            ctx.drawImage(img, 0, 0, width, height);
            originalImageData = ctx.getImageData(0, 0, width, height);
        }

        function performWatermarkDetection() {
            const results = [];

            // 1. ç»Ÿè®¡åˆ†ææ£€æµ‹
            const stats = analyzeImageStatistics();
            results.push({
                type: 'info',
                title: 'å›¾åƒç»Ÿè®¡åˆ†æ',
                content: `
                    å¹³å‡äº®åº¦: ${stats.avgBrightness.toFixed(2)}<br>
                    äº®åº¦æ ‡å‡†å·®: ${stats.brightnessStd.toFixed(2)}<br>
                    é¢œè‰²åˆ†å¸ƒç†µ: ${stats.colorEntropy.toFixed(3)}
                `
            });

            // 2. è¾¹ç¼˜æ£€æµ‹åˆ†æ
            const edgeAnalysis = performEdgeDetection();
            if (edgeAnalysis.suspiciousEdges > 100) {
                results.push({
                    type: 'warning',
                    title: 'è¾¹ç¼˜å¼‚å¸¸æ£€æµ‹',
                    content: `æ£€æµ‹åˆ° ${edgeAnalysis.suspiciousEdges} ä¸ªå¯ç–‘è¾¹ç¼˜ç‰¹å¾ï¼Œå¯èƒ½å­˜åœ¨éšè—å†…å®¹`
                });
            }

            // 3. é¢‘åŸŸåˆ†æ
            const frequencyAnalysis = analyzeFrequencyDomain();
            results.push({
                type: 'info',
                title: 'é¢‘åŸŸåˆ†æ',
                content: `
                    é«˜é¢‘æˆåˆ†: ${(frequencyAnalysis.highFreq * 100).toFixed(1)}%<br>
                    ä¸­é¢‘æˆåˆ†: ${(frequencyAnalysis.midFreq * 100).toFixed(1)}%<br>
                    ä½é¢‘æˆåˆ†: ${(frequencyAnalysis.lowFreq * 100).toFixed(1)}%
                `
            });

            // 4. LSBï¼ˆæœ€ä½æœ‰æ•ˆä½ï¼‰åˆ†æ
            const lsbAnalysis = analyzeLSB();
            if (lsbAnalysis.anomaly > 0.3) {
                results.push({
                    type: 'danger',
                    title: 'LSBéšå†™æ£€æµ‹',
                    content: `LSBä½å¼‚å¸¸åº¦: ${(lsbAnalysis.anomaly * 100).toFixed(1)}% - å¼ºçƒˆæ€€ç–‘å­˜åœ¨LSBéšå†™`
                });
            } else if (lsbAnalysis.anomaly > 0.15) {
                results.push({
                    type: 'warning',
                    title: 'LSBéšå†™æ£€æµ‹',
                    content: `LSBä½å¼‚å¸¸åº¦: ${(lsbAnalysis.anomaly * 100).toFixed(1)}% - å¯èƒ½å­˜åœ¨LSBéšå†™`
                });
            }

            // 5. é¢œè‰²ç›´æ–¹å›¾å¼‚å¸¸æ£€æµ‹
            const histogramAnalysis = analyzeColorHistogram();
            if (histogramAnalysis.anomaly > 0.4) {
                results.push({
                    type: 'warning',
                    title: 'é¢œè‰²åˆ†å¸ƒå¼‚å¸¸',
                    content: `é¢œè‰²ç›´æ–¹å›¾å¼‚å¸¸åº¦: ${(histogramAnalysis.anomaly * 100).toFixed(1)}% - æ£€æµ‹åˆ°éè‡ªç„¶é¢œè‰²åˆ†å¸ƒ`
                });
            }

            // 6. å™ªå£°æ¨¡å¼åˆ†æ
            const noiseAnalysis = analyzeNoisePattern();
            results.push({
                type: 'info',
                title: 'å™ªå£°åˆ†æ',
                content: `
                    å™ªå£°å¼ºåº¦: ${noiseAnalysis.intensity.toFixed(3)}<br>
                    å™ªå£°ä¸€è‡´æ€§: ${(noiseAnalysis.consistency * 100).toFixed(1)}%<br>
                    ${noiseAnalysis.isArtificial ? 'âš ï¸ æ£€æµ‹åˆ°äººå·¥å™ªå£°ç‰¹å¾' : 'âœ“ å™ªå£°æ¨¡å¼æ­£å¸¸'}
                `
            });

            // 7. é‡é‡‡æ ·æ£€æµ‹
            const resamplingAnalysis = detectResampling();
            if (resamplingAnalysis.likelihood > 0.6) {
                results.push({
                    type: 'warning',
                    title: 'é‡é‡‡æ ·æ£€æµ‹',
                    content: `é‡é‡‡æ ·å¯èƒ½æ€§: ${(resamplingAnalysis.likelihood * 100).toFixed(1)}% - å›¾åƒå¯èƒ½è¢«é‡æ–°ç¼©æ”¾æˆ–æ—‹è½¬è¿‡`
                });
            }

            // 8. åŒé‡å‹ç¼©æ£€æµ‹
            const compressionAnalysis = detectDoubleCompression();
            if (compressionAnalysis.likelihood > 0.5) {
                results.push({
                    type: 'warning',
                    title: 'åŒé‡å‹ç¼©æ£€æµ‹',
                    content: `åŒé‡å‹ç¼©å¯èƒ½æ€§: ${(compressionAnalysis.likelihood * 100).toFixed(1)}% - å›¾åƒå¯èƒ½ç»è¿‡å¤šæ¬¡å‹ç¼©`
                });
            }

            // 10. ä¸“é—¨çš„LSBæ°´å°æå–
            const lsbExtraction = extractLSBWatermark();
            if (lsbExtraction.found) {
                results.push({
                    type: 'danger',
                    title: 'LSBæ°´å°æå–æˆåŠŸ',
                    content: `ğŸ¯ æˆåŠŸæå–åˆ°LSBæ°´å°æ–‡æœ¬ï¼š<br><strong>"${lsbExtraction.text}"</strong><br>ç½®ä¿¡åº¦: ${(lsbExtraction.confidence * 100).toFixed(1)}%`
                });
            } else if (lsbExtraction.suspicious) {
                results.push({
                    type: 'warning',
                    title: 'LSBæ°´å°ç—•è¿¹æ£€æµ‹',
                    content: `æ£€æµ‹åˆ°LSBåµŒå…¥ç—•è¿¹ï¼Œä½†æ— æ³•å®Œå…¨æå–å†…å®¹ã€‚å¯èƒ½åŸå› ï¼š<br>â€¢ å›¾åƒç»è¿‡å‹ç¼©æˆ–å¤„ç†<br>â€¢ ä½¿ç”¨äº†ä¸åŒçš„åµŒå…¥ç®—æ³•<br>â€¢ æ°´å°å·²éƒ¨åˆ†æŸå`
                });
            }

            // 11. Alphaé€šé“æ°´å°æ£€æµ‹
            const alphaAnalysis = detectAlphaWatermark();
            if (alphaAnalysis.found) {
                results.push({
                    type: 'warning',
                    title: 'Alphaé€šé“æ°´å°',
                    content: `æ£€æµ‹åˆ°Alphaé€šé“å¼‚å¸¸æ¨¡å¼ï¼Œç–‘ä¼¼å­˜åœ¨Alphaæ°´å°<br>å¼‚å¸¸åº¦: ${(alphaAnalysis.anomaly * 100).toFixed(1)}%`
                });
            }

            // 12. é¢‘åŸŸæ°´å°æ£€æµ‹
            const freqAnalysis = detectFrequencyWatermark();
            if (freqAnalysis.found) {
                results.push({
                    type: 'warning',
                    title: 'é¢‘åŸŸæ°´å°æ£€æµ‹',
                    content: `åœ¨ç»¿è‰²é€šé“ç¬¬4ä½æ£€æµ‹åˆ°è§„å¾‹æ€§æ¨¡å¼<br>æ¨¡å¼å¼ºåº¦: ${(freqAnalysis.strength * 100).toFixed(1)}%`
                });
            }

            // 9. å—æ•ˆåº”æ£€æµ‹
            const blockingAnalysis = detectBlockingArtifacts();
            if (blockingAnalysis.severity > 0.3) {
                results.push({
                    type: 'info',
                    title: 'å—æ•ˆåº”åˆ†æ',
                    content: `å—æ•ˆåº”å¼ºåº¦: ${(blockingAnalysis.severity * 100).toFixed(1)}% - ${blockingAnalysis.severity > 0.6 ? 'å¼ºçƒˆçš„' : 'è½»å¾®çš„'}JPEGå‹ç¼©ç—•è¿¹`
                });
            }

            // åˆ›å»ºå¢å¼ºæ˜¾ç¤º
            createEnhancedDisplays();

            displayResults(results);
        }

        function analyzeImageStatistics() {
            const data = originalImageData.data;
            let totalR = 0, totalG = 0, totalB = 0;
            let brightnessValues = [];

            // è®¡ç®—åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (r + g + b) / 3;

                totalR += r;
                totalG += g;
                totalB += b;
                brightnessValues.push(brightness);
            }

            const pixelCount = data.length / 4;
            const avgBrightness = brightnessValues.reduce((a, b) => a + b) / brightnessValues.length;

            // è®¡ç®—æ ‡å‡†å·®
            const variance = brightnessValues.reduce((acc, val) => acc + Math.pow(val - avgBrightness, 2), 0) / brightnessValues.length;
            const brightnessStd = Math.sqrt(variance);

            // è®¡ç®—é¢œè‰²ç†µï¼ˆç®€åŒ–ç‰ˆï¼‰
            const histogram = new Array(256).fill(0);
            brightnessValues.forEach(val => histogram[Math.floor(val)]++);
            let colorEntropy = 0;
            histogram.forEach(count => {
                if (count > 0) {
                    const p = count / pixelCount;
                    colorEntropy -= p * Math.log2(p);
                }
            });

            return { avgBrightness, brightnessStd, colorEntropy };
        }

        function performEdgeDetection() {
            const data = originalImageData.data;
            const width = originalImageData.width;
            const height = originalImageData.height;
            let suspiciousEdges = 0;

            // Sobelç®—å­è¾¹ç¼˜æ£€æµ‹
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                            const kernelIdx = (ky + 1) * 3 + (kx + 1);

                            gx += gray * sobelX[kernelIdx];
                            gy += gray * sobelY[kernelIdx];
                        }
                    }

                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    if (magnitude > 30) suspiciousEdges++;
                }
            }

            return { suspiciousEdges };
        }

        function analyzeFrequencyDomain() {
            // ç®€åŒ–çš„é¢‘åŸŸåˆ†æï¼ˆä½¿ç”¨å›¾åƒæ¢¯åº¦æ¥ä¼°ç®—é¢‘ç‡åˆ†å¸ƒï¼‰
            const data = originalImageData.data;
            const width = originalImageData.width;
            const height = originalImageData.height;

            let highFreq = 0, midFreq = 0, lowFreq = 0;
            let totalPixels = 0;

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

                    // è®¡ç®—å‘¨å›´åƒç´ çš„æ¢¯åº¦
                    const right = ((data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3);
                    const bottom = ((data[(y + 1) * width * 4 + x * 4] + data[(y + 1) * width * 4 + x * 4 + 1] + data[(y + 1) * width * 4 + x * 4 + 2]) / 3);

                    const gradX = Math.abs(current - right);
                    const gradY = Math.abs(current - bottom);
                    const gradient = Math.sqrt(gradX * gradX + gradY * gradY);

                    if (gradient > 50) highFreq++;
                    else if (gradient > 15) midFreq++;
                    else lowFreq++;

                    totalPixels++;
                }
            }

            return {
                highFreq: highFreq / totalPixels,
                midFreq: midFreq / totalPixels,
                lowFreq: lowFreq / totalPixels
            };
        }

        function analyzeLSB() {
            const data = originalImageData.data;
            let anomalyScore = 0;
            let totalPixels = 0;

            // åˆ†æLSBä½çš„éšæœºæ€§
            const lsbHistogram = { r: new Array(2).fill(0), g: new Array(2).fill(0), b: new Array(2).fill(0) };

            for (let i = 0; i < data.length; i += 4) {
                lsbHistogram.r[data[i] & 1]++;
                lsbHistogram.g[data[i + 1] & 1]++;
                lsbHistogram.b[data[i + 2] & 1]++;
                totalPixels++;
            }

            // è®¡ç®—LSBåˆ†å¸ƒçš„åå·®ï¼ˆç†æƒ³æƒ…å†µä¸‹åº”è¯¥æ¥è¿‘50/50ï¼‰
            const expectedRatio = 0.5;
            const rDeviation = Math.abs((lsbHistogram.r[0] / totalPixels) - expectedRatio);
            const gDeviation = Math.abs((lsbHistogram.g[0] / totalPixels) - expectedRatio);
            const bDeviation = Math.abs((lsbHistogram.b[0] / totalPixels) - expectedRatio);

            anomalyScore = (rDeviation + gDeviation + bDeviation) / 3;

            return { anomaly: anomalyScore };
        }

        // é¢œè‰²ç›´æ–¹å›¾å¼‚å¸¸æ£€æµ‹
        function analyzeColorHistogram() {
            const data = originalImageData.data;
            const histR = new Array(256).fill(0);
            const histG = new Array(256).fill(0);
            const histB = new Array(256).fill(0);
            const pixelCount = data.length / 4;

            // æ„å»ºRGBç›´æ–¹å›¾
            for (let i = 0; i < data.length; i += 4) {
                histR[data[i]]++;
                histG[data[i + 1]]++;
                histB[data[i + 2]]++;
            }

            // æ£€æµ‹å¼‚å¸¸å³°å€¼å’Œåˆ†å¸ƒ
            let anomaly = 0;
            const expectedAvg = pixelCount / 256;

            [histR, histG, histB].forEach(hist => {
                let peaks = 0;
                let variance = 0;

                hist.forEach(count => {
                    if (count > expectedAvg * 3) peaks++; // å¼‚å¸¸å³°å€¼
                    variance += Math.pow(count - expectedAvg, 2);
                });

                anomaly += (peaks / 256) + (Math.sqrt(variance / 256) / pixelCount);
            });

            return { anomaly: anomaly / 3 };
        }

        // å™ªå£°æ¨¡å¼åˆ†æ
        function analyzeNoisePattern() {
            const data = originalImageData.data;
            const width = originalImageData.width;
            const height = originalImageData.height;
            let noiseValues = [];
            let totalNoise = 0;

            // è®¡ç®—å±€éƒ¨å™ªå£°å¼ºåº¦
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

                    // è®¡ç®—ä¸å‘¨å›´8ä¸ªåƒç´ çš„å·®å¼‚
                    let localNoise = 0;
                    let count = 0;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            const neighbor = (data[nIdx] + data[nIdx + 1] + data[nIdx + 2]) / 3;
                            localNoise += Math.abs(center - neighbor);
                            count++;
                        }
                    }

                    localNoise /= count;
                    noiseValues.push(localNoise);
                    totalNoise += localNoise;
                }
            }

            const intensity = totalNoise / noiseValues.length / 255;

            // è®¡ç®—å™ªå£°ä¸€è‡´æ€§ï¼ˆæ£€æµ‹äººå·¥æ·»åŠ çš„å™ªå£°ï¼‰
            const noiseAvg = totalNoise / noiseValues.length;
            let consistency = 0;
            noiseValues.forEach(noise => {
                consistency += Math.abs(noise - noiseAvg);
            });
            consistency = 1 - (consistency / noiseValues.length / noiseAvg);

            // äººå·¥å™ªå£°é€šå¸¸å…·æœ‰è¾ƒé«˜çš„ä¸€è‡´æ€§
            const isArtificial = consistency > 0.8 && intensity > 0.05;

            return { intensity, consistency, isArtificial };
        }

        // é‡é‡‡æ ·æ£€æµ‹
        function detectResampling() {
            const data = originalImageData.data;
            const width = originalImageData.width;
            const height = originalImageData.height;
            let periodicityScore = 0;
            let edgeAnomalies = 0;

            // æ£€æµ‹å‘¨æœŸæ€§æ¨¡å¼ï¼ˆé‡é‡‡æ ·çš„ç‰¹å¾ï¼‰
            for (let y = 0; y < height - 4; y += 2) {
                for (let x = 0; x < width - 4; x += 2) {
                    const samples = [];
                    for (let i = 0; i < 4; i++) {
                        const idx = ((y + i) * width + (x + i)) * 4;
                        samples.push((data[idx] + data[idx + 1] + data[idx + 2]) / 3);
                    }

                    // æ£€æµ‹çº¿æ€§æ¨¡å¼
                    const diff1 = Math.abs(samples[1] - samples[0]);
                    const diff2 = Math.abs(samples[2] - samples[1]);
                    const diff3 = Math.abs(samples[3] - samples[2]);

                    if (Math.abs(diff1 - diff2) < 2 && Math.abs(diff2 - diff3) < 2) {
                        periodicityScore++;
                    }
                }
            }

            // æ£€æµ‹è¾¹ç¼˜å¼‚å¸¸
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

                    const left = (data[idx - 4] + data[idx - 3] + data[idx - 2]) / 3;
                    const right = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;

                    // æ£€æµ‹å¼‚å¸¸é”åˆ©çš„è¾¹ç¼˜ï¼ˆé‡é‡‡æ ·é€ æˆçš„ï¼‰
                    if (Math.abs(center - left) > 50 && Math.abs(center - right) > 50) {
                        edgeAnomalies++;
                    }
                }
            }

            const totalSamples = (width / 2) * (height / 2);
            const likelihood = (periodicityScore / totalSamples) + (edgeAnomalies / (width * height) * 10);

            return { likelihood: Math.min(1, likelihood) };
        }

        // åŒé‡å‹ç¼©æ£€æµ‹
        function detectDoubleCompression() {
            const data = originalImageData.data;
            const width = originalImageData.width;
            const height = originalImageData.height;
            let blockiness = 0;
            let quantizationErrors = 0;

            // æ£€æµ‹8x8å—è¾¹ç•Œä¸Šçš„ä¸è¿ç»­æ€§ï¼ˆJPEGå‹ç¼©ç‰¹å¾ï¼‰
            for (let y = 8; y < height; y += 8) {
                for (let x = 0; x < width - 1; x++) {
                    const upperIdx = ((y - 1) * width + x) * 4;
                    const lowerIdx = (y * width + x) * 4;

                    const upperGray = (data[upperIdx] + data[upperIdx + 1] + data[upperIdx + 2]) / 3;
                    const lowerGray = (data[lowerIdx] + data[lowerIdx + 1] + data[lowerIdx + 2]) / 3;

                    blockiness += Math.abs(upperGray - lowerGray);
                }
            }

            for (let y = 0; y < height - 1; y++) {
                for (let x = 8; x < width; x += 8) {
                    const leftIdx = (y * width + (x - 1)) * 4;
                    const rightIdx = (y * width + x) * 4;

                    const leftGray = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
                    const rightGray = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;

                    blockiness += Math.abs(leftGray - rightGray);
                }
            }

            // æ£€æµ‹é‡åŒ–è¯¯å·®æ¨¡å¼
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // æ£€æµ‹ç‰¹å®šçš„é‡åŒ–çº§åˆ«
                if (r % 8 === 0 || g % 8 === 0 || b % 8 === 0) {
                    quantizationErrors++;
                }
            }

            const totalPixels = data.length / 4;
            const normalizedBlockiness = blockiness / (width * height * 255);
            const quantizationRate = quantizationErrors / totalPixels;

            const likelihood = Math.min(1, normalizedBlockiness * 2 + quantizationRate);

            return { likelihood };
        }

        // ä¸“é—¨çš„LSBæ°´å°æå– - ä¸æ·»åŠ é¡µé¢å…¼å®¹
        function extractLSBWatermark() {
            const data = originalImageData.data;
            const width = originalImageData.width;
            const height = originalImageData.height;

            try {
                // å°è¯•å¤šç§åˆ†å¸ƒæ¨¡å¼æå–
                const distributions = ['single', 'grid', 'random', 'diagonal'];
                const positions = ['center', 'topleft', 'topright', 'bottomleft', 'bottomright'];

                for (const dist of distributions) {
                    for (const pos of positions) {
                        const result = tryExtractLSB(data, width, height, pos, dist);
                        if (result.found) {
                            return result;
                        }
                    }
                }

                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å®Œæ•´æ°´å°ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰LSBåµŒå…¥ç—•è¿¹
                const hasLSBTraces = detectLSBTraces(data);
                return { found: false, suspicious: hasLSBTraces, text: '', confidence: 0 };

            } catch (error) {
                console.error('LSBæå–é”™è¯¯:', error);
                return { found: false, suspicious: false, text: '', confidence: 0 };
            }
        }

        function tryExtractLSB(data, width, height, position, distribution) {
            try {
                const watermarkPositions = calculateWatermarkPositions(width, height, position, distribution, 1000);

                // é¦–å…ˆæå–é•¿åº¦ä¿¡æ¯ï¼ˆå‰32ä½ï¼‰
                let lengthBinary = '';
                let bitIndex = 0;

                for (const startPos of watermarkPositions) {
                    for (let i = 0; i < 1000 && bitIndex < 32 && startPos + i * 4 + 2 < data.length; i++) {
                        const pixelIndex = startPos + i * 4 + 2; // è“è‰²é€šé“
                        lengthBinary += (data[pixelIndex] & 1).toString();
                        bitIndex++;
                    }
                    if (bitIndex >= 32) break;
                }

                if (lengthBinary.length < 32) return { found: false };

                const textLength = parseInt(lengthBinary, 2);
                if (textLength <= 0 || textLength > 2000) return { found: false }; // åˆç†æ€§æ£€æŸ¥

                // æå–å®é™…æ–‡æœ¬æ•°æ®
                let binaryText = '';
                bitIndex = 32; // è·³è¿‡é•¿åº¦ä¿¡æ¯
                let extractedBits = 0;

                for (const startPos of watermarkPositions) {
                    for (let i = 0; i < 1000 && extractedBits < textLength && startPos + i * 4 + 2 < data.length; i++) {
                        if (bitIndex <= 32) {
                            bitIndex++;
                            continue; // è·³è¿‡é•¿åº¦ä½
                        }
                        const pixelIndex = startPos + i * 4 + 2;
                        binaryText += (data[pixelIndex] & 1).toString();
                        extractedBits++;
                        bitIndex++;
                    }
                    if (extractedBits >= textLength) break;
                }

                if (binaryText.length < textLength) return { found: false };

                // è½¬æ¢ä¸ºæ–‡æœ¬
                const extractedText = binaryToText(binaryText);

                // éªŒè¯æå–çš„æ–‡æœ¬æ˜¯å¦åˆç†
                if (isValidText(extractedText)) {
                    return {
                        found: true,
                        text: extractedText,
                        confidence: calculateConfidence(extractedText),
                        position: position,
                        distribution: distribution
                    };
                }

                return { found: false };
            } catch (error) {
                return { found: false };
            }
        }

        function calculateWatermarkPositions(width, height, position, distribution, maxLength) {
            const positions = [];

            switch (distribution) {
                case 'single':
                    positions.push(calculateSinglePosition(width, height, position));
                    break;
                case 'grid':
                    const gridSize = 3;
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            const x = Math.floor((width / gridSize) * col + (width / gridSize) / 2);
                            const y = Math.floor((height / gridSize) * row + (height / gridSize) / 2);
                            positions.push((y * width + x) * 4);
                        }
                    }
                    break;
                case 'random':
                    // ä½¿ç”¨å›ºå®šç§å­æ¨¡æ‹Ÿéšæœºåˆ†å¸ƒ
                    for (let i = 0; i < 20; i++) {
                        const x = Math.floor((Math.sin(i * 12345) * 0.5 + 0.5) * width);
                        const y = Math.floor((Math.cos(i * 67890) * 0.5 + 0.5) * height);
                        positions.push((y * width + x) * 4);
                    }
                    break;
                case 'diagonal':
                    const steps = Math.min(10, Math.min(width, height) / 50);
                    for (let i = 0; i < steps; i++) {
                        const ratio = i / (steps - 1);
                        const x1 = Math.floor(width * ratio);
                        const y1 = Math.floor(height * ratio);
                        const x2 = Math.floor(width * (1 - ratio));
                        const y2 = Math.floor(height * ratio);
                        positions.push((y1 * width + x1) * 4);
                        positions.push((y2 * width + x2) * 4);
                    }
                    break;
            }

            return positions;
        }

        function calculateSinglePosition(width, height, position) {
            const centerX = Math.floor(width / 2);
            const centerY = Math.floor(height / 2);

            switch (position) {
                case 'topleft': return 0;
                case 'topright': return (width - 1) * 4;
                case 'bottomleft': return (height - 1) * width * 4;
                case 'bottomright': return ((height - 1) * width + (width - 1)) * 4;
                case 'center':
                default: return (centerY * width + centerX) * 4;
            }
        }

        function binaryToText(binary) {
            let text = '';
            for (let i = 0; i < binary.length; i += 8) {
                const byte = binary.substr(i, 8);
                if (byte.length === 8) {
                    const charCode = parseInt(byte, 2);
                    if (charCode > 0 && charCode < 256) {
                        text += String.fromCharCode(charCode);
                    }
                }
            }
            return text;
        }

        function isValidText(text) {
            if (!text || text.length === 0) return false;

            // æ£€æŸ¥æ˜¯å¦åŒ…å«å¯è§å­—ç¬¦
            const visibleChars = text.replace(/\s/g, '');
            if (visibleChars.length === 0) return false;

            // æ£€æŸ¥æ˜¯å¦åŒ…å«è¿‡å¤šçš„æ§åˆ¶å­—ç¬¦
            const controlChars = text.replace(/[\x20-\x7E\u4e00-\u9fff]/g, '');
            return controlChars.length / text.length < 0.3;
        }

        function calculateConfidence(text) {
            let score = 0.5;

            // é•¿åº¦åˆç†æ€§
            if (text.length >= 3 && text.length <= 100) score += 0.2;

            // åŒ…å«å­—æ¯æˆ–æ±‰å­—
            if (/[a-zA-Z\u4e00-\u9fff]/.test(text)) score += 0.2;

            // å¸¸è§çš„æ°´å°è¯æ±‡
            if (/copyright|ç‰ˆæƒ|watermark|æ°´å°|Â©|Â®|â„¢/.test(text.toLowerCase())) score += 0.3;

            return Math.min(1.0, score);
        }

        function detectLSBTraces(data) {
            // æ£€æµ‹LSBä½çš„å¼‚å¸¸æ¨¡å¼
            let consecutivePattern = 0;
            let maxConsecutive = 0;
            let lastBit = -1;

            for (let i = 2; i < data.length; i += 4) { // åªæ£€æŸ¥è“è‰²é€šé“
                const currentBit = data[i] & 1;
                if (currentBit === lastBit) {
                    consecutivePattern++;
                    maxConsecutive = Math.max(maxConsecutive, consecutivePattern);
                } else {
                    consecutivePattern = 0;
                }
                lastBit = currentBit;
            }

            return maxConsecutive > 32; // è¶…è¿‡32ä¸ªè¿ç»­ç›¸åŒä½å¯èƒ½è¡¨ç¤ºåµŒå…¥
        }

        // Alphaé€šé“æ°´å°æ£€æµ‹
        function detectAlphaWatermark() {
            const data = originalImageData.data;
            let anomalies = 0;
            let totalPixels = 0;
            let alphaVariations = [];

            for (let i = 3; i < data.length; i += 4) { // Alphaé€šé“
                const alpha = data[i];
                alphaVariations.push(alpha);

                // æ£€æŸ¥ç›¸é‚»åƒç´ çš„Alphaå€¼å·®å¼‚
                if (i >= 7) { // ç¡®ä¿æœ‰å‰ä¸€ä¸ªåƒç´ 
                    const prevAlpha = data[i - 4];
                    const diff = Math.abs(alpha - prevAlpha);
                    if (diff > 0 && diff < 10) { // å¾®å°ä½†æ˜æ˜¾çš„å·®å¼‚
                        anomalies++;
                    }
                }
                totalPixels++;
            }

            const anomalyRate = anomalies / totalPixels;
            const found = anomalyRate > 0.1; // å¦‚æœè¶…è¿‡10%çš„åƒç´ æœ‰å¼‚å¸¸

            return { found, anomaly: anomalyRate };
        }

        // é¢‘åŸŸæ°´å°æ£€æµ‹ï¼ˆç»¿è‰²é€šé“ç¬¬4ä½ï¼‰
        function detectFrequencyWatermark() {
            const data = originalImageData.data;
            let patternStrength = 0;
            let totalSamples = 0;

            for (let i = 1; i < data.length; i += 4) { // ç»¿è‰²é€šé“
                const bit4 = (data[i] >> 3) & 1; // ç¬¬4ä½

                // æ£€æŸ¥æ˜¯å¦æœ‰è§„å¾‹æ€§æ¨¡å¼
                if (i >= 5) { // ç¡®ä¿æœ‰å‰ä¸€ä¸ªåƒç´ 
                    const prevBit4 = (data[i - 4] >> 3) & 1;
                    if (bit4 === prevBit4) {
                        patternStrength++;
                    }
                }
                totalSamples++;
            }

            const strength = patternStrength / totalSamples;
            const found = strength > 0.7 || strength < 0.3; // è¿‡äºè§„å¾‹æˆ–è¿‡äºéšæœº

            return { found, strength: Math.abs(strength - 0.5) * 2 };
        }

        // å—æ•ˆåº”æ£€æµ‹
        function detectBlockingArtifacts() {
            const data = originalImageData.data;
            const width = originalImageData.width;
            const height = originalImageData.height;
            let horizontalBlocking = 0;
            let verticalBlocking = 0;
            let blockCount = 0;

            // æ£€æµ‹æ°´å¹³å—è¾¹ç•Œ
            for (let y = 8; y < height; y += 8) {
                for (let x = 0; x < width; x++) {
                    const above = ((y - 1) * width + x) * 4;
                    const below = (y * width + x) * 4;

                    if (above >= 0 && below < data.length) {
                        const aboveGray = (data[above] + data[above + 1] + data[above + 2]) / 3;
                        const belowGray = (data[below] + data[below + 1] + data[below + 2]) / 3;
                        horizontalBlocking += Math.abs(aboveGray - belowGray);
                        blockCount++;
                    }
                }
            }

            // æ£€æµ‹å‚ç›´å—è¾¹ç•Œ
            for (let y = 0; y < height; y++) {
                for (let x = 8; x < width; x += 8) {
                    const left = (y * width + (x - 1)) * 4;
                    const right = (y * width + x) * 4;

                    if (left >= 0 && right < data.length) {
                        const leftGray = (data[left] + data[left + 1] + data[left + 2]) / 3;
                        const rightGray = (data[right] + data[right + 1] + data[right + 2]) / 3;
                        verticalBlocking += Math.abs(leftGray - rightGray);
                    }
                }
            }

            const totalBlocking = (horizontalBlocking + verticalBlocking) / (blockCount * 255);
            const severity = Math.min(1, totalBlocking * 5);

            return { severity };
        }

        function createEnhancedDisplays() {
            const imageDisplay = document.getElementById('imageDisplay');

            // åˆ›å»ºå¤šç§å¢å¼ºæ˜¾ç¤º
            const enhancements = [
                { name: 'äº®åº¦å¢å¼º', func: enhanceBrightness },
                { name: 'å¯¹æ¯”åº¦å¢å¼º', func: enhanceContrast },
                { name: 'LSBå¯è§†åŒ–', func: visualizeLSB },
                { name: 'LSBæ°´å°æå–', func: visualizeLSBExtraction },
                { name: 'è¾¹ç¼˜æ£€æµ‹', func: detectEdges },
                { name: 'å™ªå£°å¯è§†åŒ–', func: visualizeNoise },
                { name: 'é¢œè‰²å·®å¼‚åˆ†æ', func: analyzeColorDifferences },
                { name: 'é«˜é¢‘åˆ†é‡', func: visualizeHighFreq }
            ];

            enhancements.forEach(enhancement => {
                const container = document.createElement('div');
                container.className = 'image-container';

                const enhancedCanvas = document.createElement('canvas');
                enhancedCanvas.width = canvas.width;
                enhancedCanvas.height = canvas.height;

                const enhancedCtx = enhancedCanvas.getContext('2d');
                enhancement.func(enhancedCtx);

                container.innerHTML = `<h3>${enhancement.name}</h3>`;
                container.appendChild(enhancedCanvas);

                imageDisplay.appendChild(container);
            });
        }

        function enhanceBrightness(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.5);     // Ré€šé“å¢å¼º
                data[i + 1] = Math.min(255, data[i + 1] * 1.5); // Gé€šé“å¢å¼º
                data[i + 2] = Math.min(255, data[i + 2] * 1.5); // Bé€šé“å¢å¼º
            }

            targetCtx.putImageData(imageData, 0, 0);
        }

        function enhanceContrast(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;
            const factor = 2.0;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, Math.min(255, (data[i] - 128) * factor + 128));
                data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - 128) * factor + 128));
                data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - 128) * factor + 128));
            }

            targetCtx.putImageData(imageData, 0, 0);
        }

        function visualizeLSB(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;

            // å°†LSBä½æ”¾å¤§æ˜¾ç¤º
            for (let i = 0; i < data.length; i += 4) {
                const rLSB = (data[i] & 1) * 255;
                const gLSB = (data[i + 1] & 1) * 255;
                const bLSB = (data[i + 2] & 1) * 255;

                data[i] = rLSB;
                data[i + 1] = gLSB;
                data[i + 2] = bLSB;
            }

            targetCtx.putImageData(imageData, 0, 0);
        }

        function visualizeLSBExtraction(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;

            // å…ˆå°†å›¾åƒè½¬ä¸ºç°åº¦èƒŒæ™¯
            for (let i = 0; i < data.length; i += 4) {
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3 * 0.3;
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }

            // é«˜äº®æ˜¾ç¤ºå¯èƒ½çš„æ°´å°åŒºåŸŸ
            const distributions = ['single', 'grid', 'random', 'diagonal'];
            const positions = ['center', 'topleft', 'topright', 'bottomleft', 'bottomright'];

            for (const dist of distributions) {
                for (const pos of positions) {
                    const watermarkPositions = calculateWatermarkPositions(
                        originalImageData.width,
                        originalImageData.height,
                        pos,
                        dist,
                        1000
                    );

                    // é«˜äº®æ˜¾ç¤ºè¿™äº›ä½ç½®
                    watermarkPositions.forEach(startPos => {
                        for (let i = 0; i < 100 && startPos + i * 4 + 2 < data.length; i++) {
                            const pixelIndex = startPos + i * 4;

                            // è“è‰²é€šé“é«˜äº®ï¼ˆLSBæ°´å°ä½ç½®ï¼‰
                            data[pixelIndex] = Math.min(255, data[pixelIndex] + 50);
                            data[pixelIndex + 1] = Math.min(255, data[pixelIndex + 1] + 50);
                            data[pixelIndex + 2] = 255; // è“è‰²é«˜äº®
                        }
                    });
                }
            }

            targetCtx.putImageData(imageData, 0, 0);
        }

        function detectEdges(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const outputData = new Uint8ClampedArray(data.length);

            // Sobelè¾¹ç¼˜æ£€æµ‹
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;

                    // è®¡ç®—Sobelç®—å­
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

                            if (kx === -1 && ky === -1) { gx -= gray; gy -= gray; }
                            else if (kx === 0 && ky === -1) { gy -= 2 * gray; }
                            else if (kx === 1 && ky === -1) { gx += gray; gy -= gray; }
                            else if (kx === -1 && ky === 0) { gx -= 2 * gray; }
                            else if (kx === 1 && ky === 0) { gx += 2 * gray; }
                            else if (kx === -1 && ky === 1) { gx -= gray; gy += gray; }
                            else if (kx === 0 && ky === 1) { gy += 2 * gray; }
                            else if (kx === 1 && ky === 1) { gx += gray; gy += gray; }
                        }
                    }

                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const outputIdx = (y * width + x) * 4;

                    outputData[outputIdx] = magnitude;
                    outputData[outputIdx + 1] = magnitude;
                    outputData[outputIdx + 2] = magnitude;
                    outputData[outputIdx + 3] = 255;
                }
            }

            const outputImageData = new ImageData(outputData, width, height);
            targetCtx.putImageData(outputImageData, 0, 0);
        }

        // å™ªå£°å¯è§†åŒ–
        function visualizeNoise(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const center = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

                    // è®¡ç®—å±€éƒ¨å˜åŒ–
                    let variance = 0;
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            const neighbor = (data[nIdx] + data[nIdx + 1] + data[nIdx + 2]) / 3;
                            variance += Math.pow(center - neighbor, 2);
                            count++;
                        }
                    }
                    variance = Math.sqrt(variance / count) * 5; // æ”¾å¤§å™ªå£°

                    data[idx] = Math.min(255, variance);
                    data[idx + 1] = Math.min(255, variance);
                    data[idx + 2] = Math.min(255, variance);
                }
            }

            targetCtx.putImageData(imageData, 0, 0);
        }

        // é¢œè‰²å·®å¼‚åˆ†æ
        function analyzeColorDifferences(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];

                    // åˆ†æRGBé€šé“å·®å¼‚
                    const rg_diff = Math.abs(r - g);
                    const rb_diff = Math.abs(r - b);
                    const gb_diff = Math.abs(g - b);

                    // çªå‡ºæ˜¾ç¤ºé¢œè‰²å¼‚å¸¸
                    if (rg_diff > 30 || rb_diff > 30 || gb_diff > 30) {
                        data[idx] = 255;
                        data[idx + 1] = Math.min(255, rg_diff * 3);
                        data[idx + 2] = Math.min(255, rb_diff * 3);
                    } else {
                        // æ­£å¸¸åŒºåŸŸæ˜¾ç¤ºä¸ºç°åº¦
                        const gray = (r + g + b) / 3;
                        data[idx] = gray * 0.3;
                        data[idx + 1] = gray * 0.3;
                        data[idx + 2] = gray * 0.3;
                    }
                }
            }

            targetCtx.putImageData(imageData, 0, 0);
        }

        // é«˜é¢‘åˆ†é‡å¯è§†åŒ–
        function visualizeHighFreq(targetCtx) {
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const outputData = new Uint8ClampedArray(data.length);

            // é«˜é€šæ»¤æ³¢å™¨å†…æ ¸
            const kernel = [
                -1, -1, -1,
                -1,  8, -1,
                -1, -1, -1
            ];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) { // RGBé€šé“
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                sum += data[idx] * kernel[kernelIdx];
                            }
                        }
                        const outputIdx = (y * width + x) * 4 + c;
                        outputData[outputIdx] = Math.max(0, Math.min(255, sum + 128));
                    }
                    outputData[(y * width + x) * 4 + 3] = 255; // Alpha
                }
            }

            const outputImageData = new ImageData(outputData, width, height);
            targetCtx.putImageData(outputImageData, 0, 0);
        }

        function setupSliderListeners() {
            const sliders = ['brightness', 'contrast', 'gamma', 'sharpen'];

            sliders.forEach(type => {
                const slider = document.getElementById(type + 'Slider');
                const valueDisplay = document.getElementById(type + 'Value');

                slider.addEventListener('input', function() {
                    let value = this.value;
                    let displayValue = value;

                    if (type === 'gamma') {
                        displayValue = (value / 100).toFixed(1);
                    } else if (type === 'sharpen') {
                        displayValue = value;
                    } else {
                        displayValue = value + '%';
                    }

                    valueDisplay.textContent = displayValue;

                    // å®æ—¶æ›´æ–°å›¾åƒå¤„ç†æ•ˆæœ
                    if (originalImageData) {
                        updateEnhancedImage();
                    }
                });
            });
        }

        function updateEnhancedImage() {
            if (!originalImageData || !canvas) return;

            const brightness = document.getElementById('brightnessSlider').value / 100;
            const contrast = document.getElementById('contrastSlider').value / 100;
            const gamma = document.getElementById('gammaSlider').value / 100;
            const sharpen = document.getElementById('sharpenSlider').value / 100;

            // åˆ›å»ºå®æ—¶è°ƒæ•´çš„å›¾åƒ
            const imageData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
            const data = imageData.data;

            // åº”ç”¨å„ç§å›¾åƒå¤„ç†æ•ˆæœ
            for (let i = 0; i < data.length; i += 4) {
                // ä¼½é©¬çŸ«æ­£
                let r = Math.pow(data[i] / 255, gamma) * 255;
                let g = Math.pow(data[i + 1] / 255, gamma) * 255;
                let b = Math.pow(data[i + 2] / 255, gamma) * 255;

                // äº®åº¦è°ƒæ•´
                r *= brightness;
                g *= brightness;
                b *= brightness;

                // å¯¹æ¯”åº¦è°ƒæ•´
                r = (r - 128) * contrast + 128;
                g = (g - 128) * contrast + 128;
                b = (b - 128) * contrast + 128;

                // é™åˆ¶å€¼èŒƒå›´
                data[i] = Math.max(0, Math.min(255, r));
                data[i + 1] = Math.max(0, Math.min(255, g));
                data[i + 2] = Math.max(0, Math.min(255, b));
            }

            // åº”ç”¨é”åŒ–æ•ˆæœ
            if (sharpen > 0) {
                applySharpenFilter(imageData, sharpen);
            }

            // æ›´æ–°å®æ—¶é¢„è§ˆç”»å¸ƒ
            updateRealtimePreview(imageData);
        }

        function applySharpenFilter(imageData, intensity) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new Uint8ClampedArray(data.length);

            // é”åŒ–å·ç§¯æ ¸
            const kernel = [
                0, -intensity, 0,
                -intensity, 1 + 4 * intensity, -intensity,
                0, -intensity, 0
            ];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) { // RGBé€šé“
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                sum += data[idx] * kernel[kernelIdx];
                            }
                        }
                        const outputIdx = (y * width + x) * 4 + c;
                        output[outputIdx] = Math.max(0, Math.min(255, sum));
                    }
                    // Alphaé€šé“ä¿æŒä¸å˜
                    output[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
                }
            }

            // å¤åˆ¶å¤„ç†åçš„æ•°æ®å›åŸæ•°ç»„
            for (let i = 0; i < data.length; i++) {
                data[i] = output[i];
            }
        }

        function updateRealtimePreview(imageData) {
            // æŸ¥æ‰¾æˆ–åˆ›å»ºå®æ—¶é¢„è§ˆå®¹å™¨
            let previewContainer = document.querySelector('.realtime-preview');
            if (!previewContainer) {
                previewContainer = document.createElement('div');
                previewContainer.className = 'image-container realtime-preview';
                previewContainer.innerHTML = '<h3>å®æ—¶è°ƒæ•´é¢„è§ˆ</h3>';

                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = canvas.width;
                previewCanvas.height = canvas.height;
                previewContainer.appendChild(previewCanvas);

                // æ’å…¥åˆ°ç¬¬äºŒä¸ªä½ç½®
                const imageDisplay = document.getElementById('imageDisplay');
                imageDisplay.insertBefore(previewContainer, imageDisplay.children[1]);
            }

            const previewCanvas = previewContainer.querySelector('canvas');
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.putImageData(imageData, 0, 0);
        }

        function displayResults(results) {
            const analysisResults = document.getElementById('analysisResults');
            analysisResults.style.display = 'block'; // æ˜¾ç¤ºç»“æœåŒºåŸŸ
            analysisResults.innerHTML = '<h3>ğŸ” æ£€æµ‹ç»“æœåˆ†æ</h3>';

            if (results.length === 0) {
                analysisResults.innerHTML += '<p>æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„æ°´å°ç‰¹å¾</p>';
                return;
            }

            results.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = `result-item ${result.type}`;
                resultDiv.innerHTML = `
                    <h4>${result.title}</h4>
                    <p>${result.content}</p>
                `;
                analysisResults.appendChild(resultDiv);
            });

            // æ·»åŠ æ£€æµ‹æ‘˜è¦
            const summary = createDetectionSummary(results);
            analysisResults.appendChild(summary);

            // æ·»åŠ æ°´å°æå–è¯¦ç»†ä¿¡æ¯
            const extractionResult = extractLSBWatermark();
            if (extractionResult.found) {
                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'result-item danger';
                detailsDiv.innerHTML = `
                    <h4>ğŸ¯ æ°´å°æå–è¯¦æƒ…</h4>
                    <p>
                        <strong>æå–åˆ°çš„æ–‡æœ¬ï¼š</strong><br>
                        <span style="font-size: 1.2em; color: #d73527; font-weight: bold; background: #fff; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">${extractionResult.text}</span><br><br>
                        <strong>æŠ€æœ¯ç»†èŠ‚ï¼š</strong><br>
                        â€¢ æ£€æµ‹ä½ç½®: ${extractionResult.position}<br>
                        â€¢ åˆ†å¸ƒæ¨¡å¼: ${extractionResult.distribution}<br>
                        â€¢ ç½®ä¿¡åº¦: ${(extractionResult.confidence * 100).toFixed(1)}%<br>
                        â€¢ åµŒå…¥é€šé“: è“è‰²é€šé“LSBä½<br>
                        â€¢ æ–‡æœ¬é•¿åº¦: ${extractionResult.text.length} å­—ç¬¦
                    </p>
                `;
                analysisResults.appendChild(detailsDiv);
            }

            // æ·»åŠ æ£€æµ‹å»ºè®®
            const suggestions = document.createElement('div');
            suggestions.className = 'result-item';
            suggestions.innerHTML = `
                <h4>ğŸ”§ æ£€æµ‹å»ºè®®</h4>
                <p>
                    â€¢ è°ƒæ•´ä¸Šæ–¹çš„å‚æ•°æ»‘å—æ¥å¢å¼ºå¯èƒ½çš„éšè—å†…å®¹<br>
                    â€¢ é‡ç‚¹å…³æ³¨<strong>LSBæ°´å°æå–</strong>å’ŒLSBå¯è§†åŒ–ç»“æœ<br>
                    â€¢ é¢œè‰²å·®å¼‚åˆ†æå¯ä»¥å¸®åŠ©å‘ç°é¢œè‰²é€šé“ä¸­çš„å¼‚å¸¸<br>
                    â€¢ é«˜é¢‘åˆ†é‡å¯è§†åŒ–èƒ½å¤Ÿçªå‡ºæ˜¾ç¤ºå›¾åƒä¸­çš„ç»†å¾®å˜åŒ–<br>
                    â€¢ å¦‚æœæ€€ç–‘å­˜åœ¨æ°´å°ï¼Œå¯ä»¥å°è¯•ä¸åŒçš„äº®åº¦å’Œå¯¹æ¯”åº¦ç»„åˆ<br>
                    â€¢ å™ªå£°åˆ†æå’Œé‡é‡‡æ ·æ£€æµ‹æœ‰åŠ©äºè¯†åˆ«å›¾åƒçš„å¤„ç†å†å²<br>
                    â€¢ Alphaé€šé“å’Œé¢‘åŸŸæ£€æµ‹èƒ½å‘ç°å…¶ä»–ç±»å‹çš„æ°´å°<br>
                    â€¢ <strong>è“è‰²é«˜äº®åŒºåŸŸ</strong>åœ¨LSBæ°´å°æå–å›¾ä¸­æ˜¾ç¤ºå¯èƒ½çš„æ°´å°ä½ç½®
                </p>
            `;
            analysisResults.appendChild(suggestions);

            // æ·»åŠ å¯¼å‡ºæŒ‰é’®
            const exportButton = document.createElement('div');
            exportButton.className = 'result-item';
            exportButton.innerHTML = `
                <h4>ğŸ“Š å¯¼å‡ºæŠ¥å‘Š</h4>
                <button class="upload-btn" onclick="exportReport()" style="margin: 0;">
                    ğŸ’¾ å¯¼å‡ºæ£€æµ‹æŠ¥å‘Š
                </button>
                <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                    å¯¼å‡ºåŒ…å«æ‰€æœ‰æ£€æµ‹ç»“æœçš„è¯¦ç»†HTMLæŠ¥å‘Š
                </p>
            `;
            analysisResults.appendChild(exportButton);
        }

        function createDetectionSummary(results) {
            const summary = document.createElement('div');
            summary.className = 'result-item';

            let dangerCount = 0;
            let warningCount = 0;
            let infoCount = 0;

            results.forEach(result => {
                if (result.type === 'danger') dangerCount++;
                else if (result.type === 'warning') warningCount++;
                else infoCount++;
            });

            let riskLevel = 'ä½é£é™©';
            let riskClass = '';
            let riskIcon = 'âœ…';

            if (dangerCount > 0) {
                riskLevel = 'é«˜é£é™©';
                riskClass = 'danger';
                riskIcon = 'âš ï¸';
            } else if (warningCount > 1) {
                riskLevel = 'ä¸­ç­‰é£é™©';
                riskClass = 'warning';
                riskIcon = 'âš¡';
            }

            summary.className += ` ${riskClass}`;
            summary.innerHTML = `
                <h4>${riskIcon} æ£€æµ‹æ‘˜è¦</h4>
                <p>
                    <strong>é£é™©è¯„ä¼°: ${riskLevel}</strong><br>
                    é«˜é£é™©é¡¹ç›®: ${dangerCount} ä¸ª<br>
                    è­¦å‘Šé¡¹ç›®: ${warningCount} ä¸ª<br>
                    ä¿¡æ¯é¡¹ç›®: ${infoCount} ä¸ª<br>
                    <br>
                    ${dangerCount > 0 ?
                        'ğŸ”´ æ£€æµ‹åˆ°å¯ç–‘çš„æ°´å°æˆ–éšå†™ç‰¹å¾ï¼Œå»ºè®®è¿›ä¸€æ­¥åˆ†æ' :
                        warningCount > 1 ?
                        'ğŸŸ¡ å­˜åœ¨ä¸€äº›å¯ç–‘è¿¹è±¡ï¼Œå¯èƒ½æœ‰è½»å¾®çš„å›¾åƒå¤„ç†ç—•è¿¹' :
                        'ğŸŸ¢ æœªå‘ç°æ˜æ˜¾çš„æ°´å°ç‰¹å¾ï¼Œå›¾åƒçœ‹èµ·æ¥æ˜¯åŸå§‹çš„'
                    }
                </p>
            `;

            return summary;
        }

        function showLoading(show) {
            const loading = document.getElementById('loading');
            loading.style.display = show ? 'block' : 'none';
        }

        // æ·»åŠ æ›´å¤šæ£€æµ‹æ–¹æ³•çš„æ‰©å±•åŠŸèƒ½
        function performAdvancedAnalysis() {
            // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šé«˜çº§æ£€æµ‹ç®—æ³•
            // ä¾‹å¦‚ï¼šDCTç³»æ•°åˆ†æã€å°æ³¢å˜æ¢åˆ†æç­‰
            console.log('æ‰§è¡Œé«˜çº§åˆ†æ...');
        }

        // å¯¼å‡ºæ£€æµ‹æŠ¥å‘ŠåŠŸèƒ½
        function exportReport() {
            const results = document.getElementById('analysisResults').innerHTML;
            const blob = new Blob([`
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <title>æ°´å°æ£€æµ‹æŠ¥å‘Š</title>
                    <style>
                        body { font-family: Microsoft YaHei, Arial, sans-serif; margin: 20px; }
                        .result-item { margin: 10px 0; padding: 10px; border-left: 4px solid #ccc; }
                        .warning { border-left-color: #ffc107; background: #fff9c4; }
                        .danger { border-left-color: #dc3545; background: #f8d7da; }
                    </style>
                </head>
                <body>
                    <h1>éšå½¢æ°´å°æ£€æµ‹æŠ¥å‘Š</h1>
                    <p>ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString('zh-CN')}</p>
                    ${results}
                </body>
                </html>
            `], { type: 'text/html' });

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'æ°´å°æ£€æµ‹æŠ¥å‘Š.html';
            a.click();
            URL.revokeObjectURL(url);
        }

        // é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey) {
                switch(e.key) {
                    case 'o': // Ctrl+O æ‰“å¼€æ–‡ä»¶
                        e.preventDefault();
                        document.getElementById('imageInput').click();
                        break;
                    case 's': // Ctrl+S å¯¼å‡ºæŠ¥å‘Š
                        e.preventDefault();
                        if (document.getElementById('analysisResults').innerHTML) {
                            exportReport();
                        }
                        break;
                }
            }
        });
    </script>
</body>
</html>