<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éšå½¢æ°´å°æ·»åŠ å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .upload-section {
            margin-bottom: 40px;
        }

        .upload-area {
            border: 3px dashed #4facfe;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: linear-gradient(45deg, #f8f9ff 0%, #e8f4fd 100%);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #00f2fe;
            background: linear-gradient(45deg, #f0f8ff 0%, #e0f0ff 100%);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #00f2fe;
            background: linear-gradient(45deg, #e8f4fd 0%, #d0e8ff 100%);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            color: #4facfe;
            margin-bottom: 20px;
        }

        .watermark-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #e9ecef;
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
            border-bottom: 2px solid #4facfe;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        input[type="text"], input[type="range"], select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        input[type="range"] {
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #4facfe, #00f2fe);
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .range-value {
            display: inline-block;
            background: #4facfe;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            margin-left: 10px;
        }

        .buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 40px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .preview-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .preview-container {
            text-align: center;
        }

        .preview-container h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2em;
        }

        .canvas-container {
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 20px;
            background: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            max-width: 100%;
            max-height: 400px;
            border-radius: 8px;
        }

        .empty-preview {
            color: #999;
            font-style: italic;
            font-size: 1.1em;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .watermark-controls {
                grid-template-columns: 1fr;
            }

            .preview-section {
                grid-template-columns: 1fr;
            }

            .content {
                padding: 20px;
            }

            .buttons {
                flex-direction: column;
                align-items: center;
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .form-group#positionGroup {
            transition: all 0.3s ease;
        }

        .form-group#positionGroup[style*="display: none"] {
            opacity: 0;
            height: 0;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ éšå½¢æ°´å°æ·»åŠ å·¥å…·</h1>
            <p>ä¸ºæ‚¨çš„å›¾ç‰‡æ·»åŠ ä¸å¯è§çš„æ•°å­—æ°´å°ï¼Œä¿æŠ¤ç‰ˆæƒçš„åŒæ—¶ä¿æŒå›¾ç‰‡ç¾è§‚</p>
        </div>

        <div class="content">
            <!-- å›¾ç‰‡ä¸Šä¼ åŒºåŸŸ -->
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“</div>
                    <h3>ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</h3>
                    <p>æ”¯æŒ JPGã€PNGã€WebP æ ¼å¼</p>
                    <input type="file" id="imageInput" accept="image/*" class="hidden">
                </div>
            </div>

            <!-- æ°´å°æ§åˆ¶é¢æ¿ -->
            <div class="watermark-controls">
                <div class="control-group">
                    <h3>æ°´å°å†…å®¹è®¾ç½®</h3>
                    <div class="form-group">
                        <label for="watermarkText">æ°´å°æ–‡æœ¬ï¼š</label>
                        <input type="text" id="watermarkText" placeholder="è¾“å…¥è¦æ·»åŠ çš„æ°´å°æ–‡æœ¬" value="ç‰ˆæƒæ‰€æœ‰ Â© 2025">
                    </div>
                    <div class="form-group">
                        <label for="watermarkType">æ°´å°ç±»å‹ï¼š</label>
                        <select id="watermarkType">
                            <option value="lsb">LSB æœ€ä½æœ‰æ•ˆä½</option>
                            <option value="alpha">Alpha é€šé“</option>
                            <option value="frequency">é¢‘åŸŸæ°´å°</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>æ°´å°å‚æ•°è°ƒæ•´</h3>
                    <div class="form-group">
                        <label for="strength">æ°´å°å¼ºåº¦ï¼š<span class="range-value" id="strengthValue">10</span></label>
                        <input type="range" id="strength" min="1" max="50" value="10">
                    </div>
                    <div class="form-group">
                        <label for="distribution">æ°´å°åˆ†å¸ƒï¼š</label>
                        <select id="distribution">
                            <option value="single">å•ç‚¹æ°´å°</option>
                            <option value="grid">ç½‘æ ¼åˆ†å¸ƒ</option>
                            <option value="random">éšæœºåˆ†å¸ƒ</option>
                            <option value="diagonal">å¯¹è§’çº¿åˆ†å¸ƒ</option>
                        </select>
                    </div>
                    <div class="form-group" id="positionGroup">
                        <label for="position">æ°´å°ä½ç½®ï¼š</label>
                        <select id="position">
                            <option value="center">å±…ä¸­</option>
                            <option value="topleft">å·¦ä¸Šè§’</option>
                            <option value="topright">å³ä¸Šè§’</option>
                            <option value="bottomleft">å·¦ä¸‹è§’</option>
                            <option value="bottomright">å³ä¸‹è§’</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- æŒ‰é’®ç»„ -->
            <div class="buttons">
                <button class="btn btn-primary" id="addWatermarkBtn" disabled>
                    <span>âœ¨ æ·»åŠ æ°´å°</span>
                </button>
                <button class="btn btn-secondary" id="previewToggleBtn" disabled>
                    <span>ğŸ‘ï¸ æ˜¾ç¤ºæ°´å°é¢„è§ˆ</span>
                </button>
                <a class="btn btn-secondary hidden" id="downloadBtn" download="watermarked_image.png">
                    <span>ğŸ’¾ ä¸‹è½½å›¾ç‰‡</span>
                </a>
            </div>

            <!-- é¢„è§ˆåŒºåŸŸ -->
            <div class="preview-section">
                <div class="preview-container">
                    <h3>åŸå§‹å›¾ç‰‡</h3>
                    <div class="canvas-container">
                        <canvas id="originalCanvas" class="hidden"></canvas>
                        <div class="empty-preview" id="originalEmpty">è¯·å…ˆä¸Šä¼ å›¾ç‰‡</div>
                    </div>
                </div>

                <div class="preview-container">
                    <h3>æ°´å°å¤„ç†ç»“æœ</h3>
                    <div class="canvas-container">
                        <canvas id="watermarkedCanvas" class="hidden"></canvas>
                        <div class="empty-preview" id="watermarkedEmpty">å¤„ç†å®Œæˆåæ˜¾ç¤ºç»“æœ</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let originalImage = null;
        let watermarkedImageData = null;
        let originalFileType = 'image/png';
        let isPreviewMode = false;

        // DOM å…ƒç´ è·å–
        const uploadArea = document.getElementById('uploadArea');
        const imageInput = document.getElementById('imageInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const watermarkedCanvas = document.getElementById('watermarkedCanvas');
        const originalEmpty = document.getElementById('originalEmpty');
        const watermarkedEmpty = document.getElementById('watermarkedEmpty');
        const addWatermarkBtn = document.getElementById('addWatermarkBtn');
        const previewToggleBtn = document.getElementById('previewToggleBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const watermarkText = document.getElementById('watermarkText');
        const watermarkType = document.getElementById('watermarkType');
        const strength = document.getElementById('strength');
        const strengthValue = document.getElementById('strengthValue');
        const distribution = document.getElementById('distribution');
        const position = document.getElementById('position');
        const positionGroup = document.getElementById('positionGroup');

        // äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–
        function initEventListeners() {
            // æ–‡ä»¶ä¸Šä¼ ç›¸å…³äº‹ä»¶
            uploadArea.addEventListener('click', () => imageInput.click());
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            imageInput.addEventListener('change', handleFileSelect);

            // æŒ‰é’®äº‹ä»¶
            addWatermarkBtn.addEventListener('click', addWatermark);
            previewToggleBtn.addEventListener('click', togglePreview);

            // èŒƒå›´æ»‘å—æ›´æ–°
            strength.addEventListener('input', (e) => {
                strengthValue.textContent = e.target.value;
            });

            // åˆ†å¸ƒæ¨¡å¼åˆ‡æ¢
            distribution.addEventListener('change', (e) => {
                positionGroup.style.display = e.target.value === 'single' ? 'block' : 'none';
            });
        }

        // æ‹–æ‹½å¤„ç†å‡½æ•°
        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        // æ–‡ä»¶å¤„ç†å‡½æ•°
        function handleFile(file) {
            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            if (!file.type.startsWith('image/')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }

            // è®°å½•åŸå§‹æ–‡ä»¶ç±»å‹
            originalFileType = file.type;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    displayOriginalImage(img);
                    // å¯ç”¨æŒ‰é’®
                    addWatermarkBtn.disabled = false;
                    // é‡ç½®é¢„è§ˆçŠ¶æ€
                    isPreviewMode = false;
                    previewToggleBtn.disabled = true;
                    previewToggleBtn.querySelector('span').textContent = 'ğŸ‘ï¸ æ˜¾ç¤ºæ°´å°é¢„è§ˆ';
                    downloadBtn.classList.add('hidden');
                    watermarkedCanvas.classList.add('hidden');
                    watermarkedEmpty.classList.remove('hidden');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // æ˜¾ç¤ºåŸå§‹å›¾ç‰‡
        function displayOriginalImage(img) {
            const ctx = originalCanvas.getContext('2d');

            // è®¡ç®—åˆé€‚çš„æ˜¾ç¤ºå°ºå¯¸
            const maxSize = 400;
            let { width, height } = calculateDisplaySize(img.width, img.height, maxSize);

            originalCanvas.width = width;
            originalCanvas.height = height;

            ctx.drawImage(img, 0, 0, width, height);

            // æ˜¾ç¤ºç”»å¸ƒï¼Œéšè—ç©ºçŠ¶æ€
            originalCanvas.classList.remove('hidden');
            originalEmpty.classList.add('hidden');
        }

        // è®¡ç®—æ˜¾ç¤ºå°ºå¯¸
        function calculateDisplaySize(originalWidth, originalHeight, maxSize) {
            let width = originalWidth;
            let height = originalHeight;

            if (width > maxSize || height > maxSize) {
                const ratio = Math.min(maxSize / width, maxSize / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            }

            return { width, height };
        }

        // æ·»åŠ æ°´å°ä¸»å‡½æ•°
        function addWatermark() {
            if (!originalImage) {
                alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼');
                return;
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const btnText = addWatermarkBtn.querySelector('span');
            const originalText = btnText.textContent;
            btnText.innerHTML = '<div class="loading"></div> å¤„ç†ä¸­...';
            addWatermarkBtn.disabled = true;

            setTimeout(() => {
                try {
                    const type = watermarkType.value;
                    const text = watermarkText.value;
                    const strengthVal = parseInt(strength.value);
                    const pos = position.value;
                    const dist = distribution.value;

                    let result;
                    switch (type) {
                        case 'lsb':
                            result = addLSBWatermark(originalImage, text, strengthVal, pos, dist);
                            break;
                        case 'alpha':
                            result = addAlphaWatermark(originalImage, text, strengthVal, pos, dist);
                            break;
                        case 'frequency':
                            result = addFrequencyWatermark(originalImage, text, strengthVal, pos, dist);
                            break;
                        default:
                            result = addLSBWatermark(originalImage, text, strengthVal, pos, dist);
                    }

                    if (result) {
                        displayWatermarkedImage(result);
                        watermarkedImageData = result;
                        // å¯ç”¨é¢„è§ˆåˆ‡æ¢æŒ‰é’®
                        previewToggleBtn.disabled = false;
                        // æ˜¾ç¤ºä¸‹è½½æŒ‰é’®
                        downloadBtn.classList.remove('hidden');
                        setupDownload();
                    }
                } catch (error) {
                    console.error('æ·»åŠ æ°´å°æ—¶å‡ºé”™:', error);
                    alert('æ·»åŠ æ°´å°å¤±è´¥ï¼Œè¯·é‡è¯•ï¼');
                } finally {
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    btnText.textContent = originalText;
                    addWatermarkBtn.disabled = false;
                }
            }, 100);
        }

        // LSB æ°´å°ç®—æ³•ï¼ˆæœ€ä½æœ‰æ•ˆä½ï¼‰
        function addLSBWatermark(img, text, strength, pos, dist) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // å°†æ–‡æœ¬è½¬æ¢ä¸ºäºŒè¿›åˆ¶
            const binaryText = textToBinary(text);
            const textLength = binaryText.length;

            // åµŒå…¥é•¿åº¦ä¿¡æ¯ï¼ˆå‰32ä½ï¼‰
            const lengthBinary = textLength.toString(2).padStart(32, '0');
            const fullBinary = lengthBinary + binaryText;

            // æ ¹æ®åˆ†å¸ƒæ¨¡å¼è®¡ç®—æ°´å°ä½ç½®
            const positions = calculateWatermarkPositions(canvas.width, canvas.height, pos, dist, fullBinary.length);

            // åµŒå…¥æ°´å°æ•°æ® - åœ¨æ¯ä¸ªä½ç½®éƒ½åµŒå…¥å®Œæ•´æ•°æ®æä¾›å†—ä½™
            for (const startPos of positions) {
                for (let i = 0; i < fullBinary.length && startPos + i * 4 + 2 < data.length; i++) {
                    const pixelIndex = startPos + i * 4 + 2; // ç›´æ¥å®šä½åˆ°è“è‰²é€šé“
                    const bit = parseInt(fullBinary[i]);

                    // ä¿®æ”¹è“è‰²é€šé“çš„æœ€ä½æœ‰æ•ˆä½
                    data[pixelIndex] = (data[pixelIndex] & 0xFE) | bit;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Alpha é€šé“æ°´å°
        function addAlphaWatermark(img, text, strength, pos, dist) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // å°†æ–‡æœ¬è½¬æ¢ä¸ºäºŒè¿›åˆ¶å¹¶æ·»åŠ é•¿åº¦ä¿¡æ¯
            const binaryText = textToBinary(text);
            const textLength = binaryText.length;
            const lengthBinary = textLength.toString(2).padStart(32, '0');
            const fullBinary = lengthBinary + binaryText;

            const positions = calculateWatermarkPositions(canvas.width, canvas.height, pos, dist, fullBinary.length);

            // åœ¨ alpha é€šé“ä¸­åµŒå…¥æ°´å° - åœ¨æ¯ä¸ªä½ç½®åµŒå…¥å®Œæ•´æ•°æ®
            for (const startPos of positions) {
                for (let i = 0; i < fullBinary.length && startPos + i * 4 + 3 < data.length; i++) {
                    const pixelIndex = startPos + i * 4 + 3; // Alpha é€šé“
                    const bit = parseInt(fullBinary[i]);

                    if (bit === 1) {
                        data[pixelIndex] = Math.max(0, data[pixelIndex] - strength);
                    } else {
                        data[pixelIndex] = Math.min(255, data[pixelIndex] + strength);
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // é¢‘åŸŸæ°´å°ï¼ˆç®€åŒ–ç‰ˆDCTï¼‰
        function addFrequencyWatermark(img, text, strength, pos, dist) {
            // è¿™é‡Œå®ç°ä¸€ä¸ªç®€åŒ–çš„é¢‘åŸŸæ°´å°ï¼Œå®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„DCTå˜æ¢
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // å°†æ–‡æœ¬è½¬æ¢ä¸ºäºŒè¿›åˆ¶å¹¶æ·»åŠ é•¿åº¦ä¿¡æ¯
            const binaryText = textToBinary(text);
            const textLength = binaryText.length;
            const lengthBinary = textLength.toString(2).padStart(32, '0');
            const fullBinary = lengthBinary + binaryText;

            const positions = calculateWatermarkPositions(canvas.width, canvas.height, pos, dist, fullBinary.length);

            // åœ¨ä¸­é¢‘åˆ†é‡ä¸­åµŒå…¥æ°´å° - åœ¨æ¯ä¸ªä½ç½®åµŒå…¥å®Œæ•´æ•°æ®
            for (const startPos of positions) {
                for (let i = 0; i < fullBinary.length && startPos + i * 4 + 1 < data.length; i++) {
                    const pixelIndex = startPos + i * 4 + 1; // ç»¿è‰²é€šé“
                    const bit = parseInt(fullBinary[i]);

                    // ä¿®æ”¹ç»¿è‰²é€šé“çš„ä¸­é—´ä½
                    if (bit === 1) {
                        data[pixelIndex] = data[pixelIndex] | (1 << 3);
                    } else {
                        data[pixelIndex] = data[pixelIndex] & ~(1 << 3);
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // æ–‡æœ¬è½¬äºŒè¿›åˆ¶
        function textToBinary(text) {
            return Array.from(text).map(char =>
                char.charCodeAt(0).toString(2).padStart(8, '0')
            ).join('');
        }

        // äºŒè¿›åˆ¶è½¬æ–‡æœ¬
        function binaryToText(binary) {
            let text = '';
            for (let i = 0; i < binary.length; i += 8) {
                const byte = binary.substr(i, 8);
                if (byte.length === 8) {
                    text += String.fromCharCode(parseInt(byte, 2));
                }
            }
            return text;
        }

        // è®¡ç®—æ°´å°ä½ç½®ï¼ˆæ”¯æŒåˆ†å¸ƒï¼‰
        function calculateWatermarkPositions(width, height, position, distribution, dataLength) {
            const totalPixels = width * height;
            const positions = [];

            switch (distribution) {
                case 'single':
                    positions.push(calculateSinglePosition(width, height, position));
                    break;
                case 'grid':
                    const gridSize = 3; // 3x3ç½‘æ ¼
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            const x = Math.floor((width / gridSize) * col + (width / gridSize) / 2);
                            const y = Math.floor((height / gridSize) * row + (height / gridSize) / 2);
                            positions.push((y * width + x) * 4);
                        }
                    }
                    break;
                case 'random':
                    // ä½¿ç”¨å›ºå®šç§å­ç¡®ä¿å¯é‡ç°çš„éšæœºåˆ†å¸ƒ
                    const numPositions = Math.min(20, Math.floor(totalPixels / (dataLength * 2))); // 20ä¸ªéšæœºä½ç½®
                    for (let i = 0; i < numPositions; i++) {
                        const randomX = Math.floor((Math.sin(i * 12345) * 0.5 + 0.5) * width);
                        const randomY = Math.floor((Math.cos(i * 67890) * 0.5 + 0.5) * height);
                        positions.push((randomY * width + randomX) * 4);
                    }
                    break;
                case 'diagonal':
                    const diagonalSteps = Math.min(10, Math.min(width, height) / 50); // å¯¹è§’çº¿åˆ†å¸ƒ
                    for (let i = 0; i < diagonalSteps; i++) {
                        const ratio = i / (diagonalSteps - 1);
                        const x = Math.floor(width * ratio);
                        const y = Math.floor(height * ratio);
                        positions.push((y * width + x) * 4);
                        // åå¯¹è§’çº¿
                        const x2 = Math.floor(width * (1 - ratio));
                        const y2 = Math.floor(height * ratio);
                        positions.push((y2 * width + x2) * 4);
                    }
                    break;
                default:
                    positions.push(calculateSinglePosition(width, height, 'center'));
            }

            return positions;
        }

        // è®¡ç®—å•ç‚¹æ°´å°ä½ç½®
        function calculateSinglePosition(width, height, position) {
            const centerX = Math.floor(width / 2);
            const centerY = Math.floor(height / 2);

            switch (position) {
                case 'topleft':
                    return 0;
                case 'topright':
                    return (width - 1) * 4;
                case 'bottomleft':
                    return (height - 1) * width * 4;
                case 'bottomright':
                    return ((height - 1) * width + (width - 1)) * 4;
                case 'center':
                default:
                    return (centerY * width + centerX) * 4;
            }
        }

        // æ˜¾ç¤ºåŠ æ°´å°åçš„å›¾ç‰‡
        function displayWatermarkedImage(canvas) {
            const ctx = watermarkedCanvas.getContext('2d');

            // è®¡ç®—æ˜¾ç¤ºå°ºå¯¸
            const maxSize = 400;
            let { width, height } = calculateDisplaySize(canvas.width, canvas.height, maxSize);

            watermarkedCanvas.width = width;
            watermarkedCanvas.height = height;

            ctx.drawImage(canvas, 0, 0, width, height);

            // æ˜¾ç¤ºç”»å¸ƒ
            watermarkedCanvas.classList.remove('hidden');
            watermarkedEmpty.classList.add('hidden');
        }

        // åˆ‡æ¢é¢„è§ˆæ¨¡å¼
        function togglePreview() {
            if (!watermarkedImageData) {
                alert('è¯·å…ˆæ·»åŠ æ°´å°ï¼');
                return;
            }

            isPreviewMode = !isPreviewMode;
            const btnText = previewToggleBtn.querySelector('span');

            if (isPreviewMode) {
                // æ˜¾ç¤ºæ˜æ˜¾çš„æ°´å°é¢„è§ˆ
                displayVisibleWatermark();
                btnText.textContent = 'ğŸ”’ éšè—æ°´å°é¢„è§ˆ';
            } else {
                // æ˜¾ç¤ºéšå½¢æ°´å°ç»“æœ
                displayWatermarkedImage(watermarkedImageData);
                btnText.textContent = 'ğŸ‘ï¸ æ˜¾ç¤ºæ°´å°é¢„è§ˆ';
            }
        }

        // æ˜¾ç¤ºæ˜æ˜¾çš„æ°´å°é¢„è§ˆ
        function displayVisibleWatermark() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = watermarkedImageData.width;
            canvas.height = watermarkedImageData.height;
            ctx.drawImage(watermarkedImageData, 0, 0);

            const text = watermarkText.value;
            const dist = distribution.value;
            const pos = position.value;

            // æ·»åŠ å¯è§æ°´å°
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.font = `${Math.max(16, Math.min(canvas.width, canvas.height) / 20)}px Arial`;
            ctx.textAlign = 'center';
            ctx.lineWidth = 2;

            const positions = calculateVisibleWatermarkPositions(canvas.width, canvas.height, pos, dist);

            positions.forEach(position => {
                ctx.strokeText(text, position.x, position.y);
                ctx.fillText(text, position.x, position.y);
            });

            displayWatermarkedImage(canvas);
        }

        // è®¡ç®—å¯è§æ°´å°ä½ç½®
        function calculateVisibleWatermarkPositions(width, height, position, distribution) {
            const positions = [];

            switch (distribution) {
                case 'single':
                    positions.push(getSingleVisiblePosition(width, height, position));
                    break;
                case 'grid':
                    const gridSize = 3;
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            const x = (width / gridSize) * col + (width / gridSize) / 2;
                            const y = (height / gridSize) * row + (height / gridSize) / 2;
                            positions.push({ x, y });
                        }
                    }
                    break;
                case 'random':
                    for (let i = 0; i < 8; i++) {
                        const x = Math.random() * width;
                        const y = Math.random() * height;
                        positions.push({ x, y });
                    }
                    break;
                case 'diagonal':
                    for (let i = 0; i < 5; i++) {
                        const ratio = i / 4;
                        const x1 = width * ratio;
                        const y1 = height * ratio;
                        const x2 = width * (1 - ratio);
                        const y2 = height * ratio;
                        positions.push({ x: x1, y: y1 });
                        positions.push({ x: x2, y: y2 });
                    }
                    break;
            }

            return positions;
        }

        // è·å–å•ç‚¹å¯è§æ°´å°ä½ç½®
        function getSingleVisiblePosition(width, height, position) {
            const centerX = width / 2;
            const centerY = height / 2;

            switch (position) {
                case 'topleft': return { x: width * 0.25, y: height * 0.25 };
                case 'topright': return { x: width * 0.75, y: height * 0.25 };
                case 'bottomleft': return { x: width * 0.25, y: height * 0.75 };
                case 'bottomright': return { x: width * 0.75, y: height * 0.75 };
                case 'center':
                default: return { x: centerX, y: centerY };
            }
        }

        // è®¾ç½®ä¸‹è½½åŠŸèƒ½
        function setupDownload() {
            if (watermarkedImageData) {
                // ä¿æŒåŸå§‹æ–‡ä»¶æ ¼å¼
                const dataURL = watermarkedImageData.toDataURL(originalFileType);
                downloadBtn.href = dataURL;

                // è®¾ç½®æ–‡ä»¶åå’Œæ‰©å±•å
                const extension = originalFileType.split('/')[1] || 'png';
                downloadBtn.download = `watermarked_image.${extension}`;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initEventListeners);
    </script>
</body>
</html>